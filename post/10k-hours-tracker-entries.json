{
  "postId": "10k-hours-tracker",
  "entries": [
    {
      "id": 1,
      "timestamp": "2026-02-04T00:00:00Z",
      "title": "Idea: Aplicaci√≥n 10K Hours Tracker",
      "text": "Se me ocurri√≥ crear una aplicaci√≥n para trackear las horas que dedico a diferentes temas o habilidades. La inspiraci√≥n viene de la Teor√≠a de las 10,000 horas de Malcolm Gladwell, que propone que se necesitan aproximadamente 10,000 horas de pr√°ctica deliberada para alcanzar el nivel de experto en cualquier disciplina.\n\nConcepto de la interfaz: La visualizaci√≥n estar√≠a inspirada en el contribution graph de GitHub (ese calendario con cuadros verdes que muestra la actividad de commits). Quiero que el usuario pueda ver su progreso de forma visual y clara, similar a c√≥mo GitHub representa la actividad diaria.\n\nFuncionalidad principal: El usuario podr√° registrar su progreso d√≠a a d√≠a. Por ejemplo: 'Hoy practiqu√© 3 horas de piano' se registra, y la app ir√° acumulando y visualizando todo el historial de pr√°ctica, mostrando el avance hacia la meta de las 10,000 horas.\n\nPr√≥ximos pasos: Tengo planeada una integraci√≥n adicional con IA, pero eso lo detallar√© en la siguiente nota."
    },
    {
      "id": 2,
      "timestamp": "2026-02-04T01:00:00Z",
      "title": "Stack T√©cnico y Primeros Pasos",
      "text": "Durante estas sesiones ir√© documentando todo el progreso del desarrollo. Ser√° una app Android por el momento, ya que es m√°s sencillo desplegarla.\n\nMetodolog√≠a: El desarrollo ser√° principalmente mediante vibe coding - yo genero las instrucciones y Claude Sonnet 4.5 se encarga de escribir todo el c√≥digo, la base de datos, y los requerimientos t√©cnicos/funcionales. El objetivo es no escribir absolutamente una sola l√≠nea de c√≥digo manualmente.\n\nStack tecnol√≥gico: Runtime Bun (extremadamente r√°pido), Backend con Hono (framework web), Base de datos PostgreSQL, y ORM Prisma.\n\nEsquema de base de datos actual: Claude Code ya gener√≥ un esquema inicial bastante bueno con tres tablas principales: User (tabla de usuarios), Skills (los temas o habilidades que queremos trackear, ej: piano, programaci√≥n), y Sessions (las horas registradas, relacionadas a cada skill).\n\nEstado actual: Estoy trabajando en los endpoints de registro de usuario. Ya tengo los requerimientos t√©cnicos definidos y voy a crear pruebas automatizadas para validar el flujo de registro."
    },
    {
      "id": 3,
      "timestamp": "2026-02-04T02:00:00Z",
      "title": "Dise√±o UI, Flutter y Arquitectura Limpia",
      "text": "He estado revisando algunos temas y paletas de color para ver c√≥mo pudiera hacer la aplicaci√≥n. Estoy pensando seriamente en un verde, pero no lo s√©, como con verdes un poco raro pero probablemente s√≠, dependiendo de c√≥mo se vea. Por ah√≠ voy a decirle a Claude que me genere un tema para Flutter.\n\nYo la neta no s√© nada de Flutter, literal no s√© nada de Flutter. Entonces ¬øc√≥mo le voy a hacer para saber si voy por el lugar correcto, que est√° escribiendo las instrucciones correctas? Pues por ah√≠ utilic√© instrucciones bien definidas que investigu√©, o que la misma gente tambi√©n investig√≥ y que sabe c√≥mo tener una buena arquitectura y una buena estructura en Flutter.\n\nQuiero evitar que se creen archivos muy gigantes porque me ha pasado en el pasado que el LLM como que en Flutter crea archivos demasiado grandes. Y pues queremos evitar eso porque para la ventana del contexto de un LLM es mucho m√°s complicado leer un archivo que es muy grande - es m√°s sencillo que el LLM lea archivos peque√±os y tenga como que mayor contexto del problema al que se va a enfrentar.\n\nProgreso actual: Parece que ya puedo registrarme, voy a hacer el login. Por ah√≠ lanc√© unas pruebas de integraci√≥n tambi√©n totalmente automatizadas. Ahora mismo estoy viendo la interfaz de usuario, cu√°l ser√° el mejor dise√±o. Estoy viendo algunos buenos dise√±os y los voy a pasar al modelo para que analice las im√°genes y a partir de ah√≠ ya me genere pues algo bello. ¬°Vamos a ver qu√© onda raza!"
    },
    {
      "id": 4,
      "timestamp": "2026-02-04T08:45:10Z",
      "title": "Login, Backend y Perfil de Usuario",
      "text": "Al final, si optamos por usar el tema verde, entonces as√≠ vamos a dise√±ar la aplicaci√≥n con ese tema verde-cinch. Ya logramos crear el login conectado con el backend. Lanc√© unas pruebas y todo pas√≥ correctamente. Tambi√©n logramos conectar Nodemailer para mandar correos de verificaci√≥n en el login, con un c√≥digo de verificaci√≥n que el usuario debe ingresar cuando se registra.\n\nVi un dise√±o de navegador, un tabulador (App Tab) en Google que me gust√≥ mucho. El modelo lo replic√≥ muy bien; se ve excelente.\n\nLogr√© crear la secci√≥n de perfil donde se muestran los datos del usuario: correo, nombre, la opci√≥n para cambiar contrase√±a y un bot√≥n para cerrar sesi√≥n. Sin embargo, el bot√≥n para cerrar sesi√≥n no est√° funcionando correctamente; devuelve una excepci√≥n. Voy a investigar por qu√© ocurre esto.\n\nHasta aqu√≠ mi reporte.",
      "image": "post/entry-4-app-tab.png",
      "imageCaption": "Dise√±o del App Tab replicado por el modelo"
    },
    {
      "id": 5,
      "timestamp": "2026-02-05T02:14:37Z",
      "title": "M√≥dulo de Skills, Cron√≥metro y Rachas",
      "text": "## Resumen del avance del 4 de febrero de 2026\n\nHoy implementamos el m√≥dulo completo de **Skills** con las siguientes funcionalidades:\n\n### CRUD de Skills\n- **Crear** un nuevo skill para dar seguimiento a las 10,000 horas\n- **Editar** skill: cambiar t√≠tulo, emoji y color de la interfaz\n- **Eliminar** skills\n\n### Cron√≥metro de Pr√°ctica\nImplementamos un cron√≥metro que cuenta las horas de pr√°ctica en tiempo real:\n- En la interfaz se visualiza el tiempo transcurrido\n- En la app m√≥vil funciona en background con notificaciones mostrando el progreso\n- Al detener el cron√≥metro se genera autom√°ticamente una nueva entrada de sesi√≥n\n\n### Sesiones Manuales\nTambi√©n se puede crear una sesi√≥n de forma manual con:\n- T√≠tulo personalizado\n- Comentarios sobre la pr√°ctica\n- Fecha espec√≠fica\n\n*Aunque el cron√≥metro es m√°s intuitivo y conveniente.*\n\n### Sistema de Rachas (Streaks)\nAgregamos la funcionalidad de rachas en el header:\n- Muestra el n√∫mero de d√≠as consecutivos de pr√°ctica\n- Sirve como incentivo y motivaci√≥n para no perder la racha\n\n### Visualizador tipo GitHub\nImplementamos un visualizador de actividad estilo GitHub (contribution graph). Por el momento funciona bien, pero se puede mejorar en futuras iteraciones.\n\n---\n\n**Estado:** Las funcionalidades principales est√°n completas. Quedan algunos ajustes de UI por pulir.",
      "image": "post/entry-5-skills-module.png",
      "imageCaption": "M√≥dulo de Skills con cron√≥metro y visualizador de actividad"
    },
    {
      "id": 6,
      "timestamp": "2026-02-05T08:45:04Z",
      "title": "Temporizador Minimalista y M√≥dulo de Resumen",
      "text": "## Avances del 5 de febrero de 2026\n\nHoy trabajamos en varias mejoras importantes para la experiencia de usuario.\n\n### Temporizador Redise√±ado\nEl temporizador ahora es **m√°s minimalista** porque la versi√≥n anterior ocupaba demasiado espacio en pantalla:\n- Corre en **background** cuando cierras la aplicaci√≥n\n- Muestra el progreso en las **notificaciones** del sistema\n- Al dar clic en la notificaci√≥n, abre la app autom√°ticamente\n\n### Nueva Navegaci√≥n (Tab Nav)\nRedise√±amos el navegador inferior con tres secciones:\n- üè† **Home** - Casita como pantalla principal\n- ‚ù§Ô∏è **Resumen General** - Nuevo m√≥dulo central\n- üë§ **Perfil** - Configuraci√≥n del usuario\n\n### M√≥dulo de Resumen General\nEste nuevo m√≥dulo muestra estad√≠sticas consolidadas:\n- **Total de horas** acumuladas en todos los skills\n- **N√∫mero de skills** que est√°s trackeando\n- **Media promedio** de horas por skill\n- üìä **Gr√°fica de horas por mes** - Visualizaci√≥n del progreso mensual vs mes anterior\n\n### Fecha Estimada de Meta\nAgregamos una caracter√≠stica muy √∫til:\n- Calcula **cu√°ndo alcanzar√°s las 10,000 horas** bas√°ndose en tu historial\n- Te dice si faltan 10, 20, 140 d√≠as... seg√∫n tu ritmo actual\n\n### Rachas por Skill\nAhora puedes ver la **racha individual** de cada skill en una lista dedicada.\n\n---\n\n**Pr√≥ximo paso:** Estoy trabajando en un **onboarding para nuevos usuarios** que explicar√° en qu√© consiste la app, guiar√° la creaci√≥n del primer skill y dar√° una vista general de las funcionalidades.",
      "image": "post/entry-6-summary-module.png",
      "imageCaption": "Nuevo m√≥dulo de resumen general con estad√≠sticas"
    },
    {
      "id": 7,
      "timestamp": "2026-02-06T09:21:02Z",
      "title": "Logo, Redise√±o del Home y Compartir en Instagram",
      "text": "## Avances del 6 de febrero de 2026 ‚Äî Devlog D√≠a 3\n\nHoy fue un d√≠a bastante productivo. Trabajamos en identidad visual, mejoras de UX y un feature que creemos va a darle mucha tracci√≥n a la app.\n\n### üé® Nuevo Logo\nCreamos un logotipo minimalista inspirado en el grid de la app: una cuadr√≠cula con diferentes colores que representan cada skill, acompa√±ada de las letras \"TenK\". Para instalarlo en todas las plataformas (Android, iOS, Web y macOS), utilizamos la librer√≠a `flutter_launcher_icons`. Qued√≥ limpio y representa bien el concepto de la app.\n\n### ‚ú® Animaci√≥n de Splash\nAgregamos una animaci√≥n al iniciar la aplicaci√≥n donde los cuadros del grid se van rellenando uno a uno con color. Se ve muy est√©tico, le da personalidad a la app desde el primer segundo.\n\n### üè† Redise√±o del Home\nHicimos un redise√±o completo de la pantalla principal:\n- **Antes:** Se mostraban todos los cuadros de las 10,000 horas de golpe, lo cual resultaba abrumador y desmotivante para el usuario.\n- **Ahora:** Primero aparece todo el progreso real del usuario, seguido de unos pocos cuadros vac√≠os. Se agreg√≥ un bot√≥n para ver la cuadr√≠cula completa en una pantalla separada.\n- El resultado es una vista mucho m√°s limpia y motivadora.\n\n### üì∏ Compartir Progreso en Instagram Stories\nImplementamos la funcionalidad de compartir una historia a Instagram con:\n- El **grid de progreso** del skill, donde las horas practicadas hoy se iluminan con mayor brillo.\n- **Total de horas** acumuladas y horas restantes para la meta.\n- **Racha actual** de d√≠as consecutivos.\n- **Nivel del usuario** (del nuevo sistema de niveles).\n\nEsta imagen se genera autom√°ticamente y tiene un dise√±o pensado para verse viral en redes. Creemos que este feature va a darle mucha potencia a la app, ya que los usuarios podr√°n compartir su progreso de forma visual y atractiva ‚Äî algo similar a como la gente comparte sus rutas de correr, pero aqu√≠ compartimos el grid de horas invertidas.\n\n### üèÜ Sistema de Niveles\nAgregamos 5 niveles de maestr√≠a:\n1. **Principiante**\n2. **Aprendiz**\n3. **Intermedio**\n4. **Avanzado**\n5. **Master**\n\nAdem√°s, en la interfaz mostramos cu√°ntas horas faltan para alcanzar el siguiente nivel, lo que a√±ade un elemento extra de motivaci√≥n para el usuario.\n\n---\n\n**Pr√≥ximo paso:** Desplegar la app en Google Play como MVP funcional. Todo parece estar funcionando correctamente. Vamos a preparar el lanzamiento para testing cerrado con 12 personas, que es el m√≠nimo que requiere Google para el programa de pruebas internas.",
      "image": "post/post7.png",
      "imageCaption": "Logo, redise√±o del Home y compartir progreso en Instagram Stories"
    },
    {
      "id": 8,
      "timestamp": "2026-02-10T23:32:55Z",
      "title": "Google Play, Infraestructura Cloud y T√©cnica Pomodoro",
      "text": "## Avances del 10 de febrero de 2026 ‚Äî Devlog D√≠a 7\n\nHoy fue un d√≠a clave: la app ya est√° desplegada en Google Play Console y la infraestructura cloud qued√≥ lista. Adem√°s, trabajamos en mejoras importantes de UX y en la landing page.\n\n### üöÄ Despliegue en Google Play Console\nLogramos completar todo el proceso de despliegue en la **Google Play Console** en modo testing:\n- Llenamos todos los requisitos obligatorios: pol√≠tica de privacidad, clasificaci√≥n de contenido y cuestionarios de seguridad de datos.\n- Subimos el **logo de la aplicaci√≥n**, las **capturas de pantalla** y la **portada** (dise√±o generado con IA).\n- La app ya est√° disponible para el programa de pruebas internas.\n\n### ‚òÅÔ∏è Infraestructura y Dominio\nConfiguramos el dominio **tenk.oventlabs.com** con una arquitectura cloud robusta:\n- **Balanceador de carga** con un target group apuntando a la instancia y al puerto donde corre la aplicaci√≥n.\n- **Certificados SSL** configurados en el balanceador de carga para servir tr√°fico HTTPS.\n- **Reglas de enrutamiento** basadas en el header del host: cuando se accede a `tenk.oventlabs.com`, el tr√°fico se redirige a la instancia correspondiente.\n- **Registros DNS** configurados en el hosting para apuntar al balanceador de carga.\n\n### üîÑ Proxy Reverso con Nginx\nConfiguramos **Nginx como proxy reverso** para unificar las rutas de la app y la API bajo el mismo dominio:\n- La API corre en un **contenedor Docker** dentro del servidor.\n- Al acceder a `tenk.oventlabs.com/api`, Nginx redirige las peticiones al contenedor correspondiente.\n- Esto simplifica la comunicaci√≥n entre el frontend y el backend, eliminando problemas de CORS y manteniendo una URL limpia.\n\n### üçÖ T√©cnica Pomodoro en el Cron√≥metro\nAgregamos la **t√©cnica Pomodoro** al temporizador de pr√°ctica:\n- **25 minutos** de pr√°ctica enfocada\n- **5 minutos** de descanso entre sesiones\n- Despu√©s de **4 sesiones**, un descanso largo de **15 minutos**\n- Los usuarios ahora pueden estructurar su pr√°ctica deliberada siguiendo esta metodolog√≠a probada de productividad.\n\n### üåê Landing Page y Lista de Acceso Anticipado\nCreamos una **landing page** en [tenk.oventlabs.com](https://tenk.oventlabs.com) con:\n- Explicaci√≥n clara del **funcionamiento principal** de la aplicaci√≥n.\n- Bot√≥n para unirse a la **lista de acceso anticipado** con el √≠cono de Google Play Store.\n- Los usuarios pueden **registrarse desde la web** sin necesidad de descargar la app.\n- La landing page permite que las personas conozcan la app y reserven su lugar antes del lanzamiento p√∫blico.\n\n---\n\n**Estado:** La app ya est√° en Google Play (testing), la infraestructura cloud est√° operativa y la landing page est√° recibiendo registros. ¬°Vamos con todo! üî•",
      "images": [
        {
          "src": "post/post9phone.png",
          "caption": "Captura de pantalla de la app m√≥vil ‚Äî Vista principal"
        },
        {
          "src": "post/post9phone2.png",
          "caption": "Captura de pantalla de la app m√≥vil ‚Äî T√©cnica Pomodoro"
        },
        {
          "src": "post/web.png",
          "caption": "Landing page ‚Äî Versi√≥n web con registro de acceso anticipado"
        }
      ]
    },
    {
      "id": 9,
      "timestamp": "2026-02-10T23:59:00Z",
      "title": "AI Coach: Integrando Claude como Entrenador Personal de Skills",
      "text": "## Avances del 10 de febrero de 2026 ‚Äî Devlog: AI Coach\n\nEsta es probablemente la feature m√°s ambiciosa que hemos construido hasta ahora. La app TenK ahora tiene un **AI Coach** integrado que analiza tus datos de pr√°ctica y te da recomendaciones personalizadas. Y lo mejor: funciona con tu propia cuenta de Claude.\n\n---\n\n### üß† ¬øQu√© es el AI Coach?\n\nEs un agente de IA con acceso a tus datos reales mediante **tool calling**. No es un chatbot gen√©rico ‚Äî el agente tiene 5 herramientas que consultan tu base de datos:\n\n| Tool | Descripci√≥n |\n|------|-------------|\n| `get_user_skills` | Skills del usuario con horas totales, nivel de maestr√≠a y estado |\n| `get_practice_sessions` | Sesiones de pr√°ctica de un skill espec√≠fico (√∫ltimos N d√≠as) |\n| `get_journey_stats` | Estad√≠sticas globales: promedio semanal, mejores d√≠as, proyecciones, rachas |\n| `analyze_practice_patterns` | Distribuci√≥n por d√≠a de semana, tendencias, gaps, diagn√≥stico de plateau |\n| `save_weekly_plan` | Guarda un plan semanal con insights en la base de datos |\n\nEl agente opera en un **loop de hasta 5 iteraciones** de tool calling. En cada iteraci√≥n, Claude decide qu√© herramientas invocar, recibe los resultados, y puede hacer m√°s llamadas o generar la respuesta final.\n\n```typescript\n// agent-runner.ts ‚Äî Loop principal\nfor (let i = 0; i < MAX_TOOL_ITERATIONS; i++) {\n  const result = await chatCompletion(messages, AGENT_TOOLS, userId);\n\n  if (result.toolCalls.length === 0) {\n    return { response: result.content, toolsUsed, provider, usage };\n  }\n\n  messages.push({ role: 'assistant', content: result.content, tool_calls: result.toolCalls });\n\n  for (const toolCall of result.toolCalls) {\n    const toolResult = await executeTool(toolCall.function.name, userId, args);\n    messages.push({ role: 'tool', content: JSON.stringify(toolResult), tool_call_id: toolCall.id });\n  }\n}\n```\n\nCada herramienta recibe el `userId` para **aislamiento de datos** ‚Äî un usuario nunca puede ver datos de otro.\n\n---\n\n### üîê OAuth PKCE con Claude: La Parte Dif√≠cil\n\nEn lugar de usar una API key centralizada (que comparte rate limits entre todos), implementamos un flujo **OAuth PKCE** donde cada usuario conecta su propia cuenta de Claude Pro o Max.\n\n#### El flujo completo:\n1. El usuario toca el √≠cono de conexi√≥n en la pantalla del coach.\n2. El backend genera un `code_verifier` (64 chars random) y su `code_challenge` (SHA-256 + base64url).\n3. Se abre el navegador con la URL de autorizaci√≥n de Claude.\n4. El usuario se logea con su cuenta de Anthropic y autoriza.\n5. Claude muestra un c√≥digo en formato `code#state` que el usuario pega en la app.\n6. El backend parsea el `#`, valida el `state` contra la DB, e intercambia el c√≥digo por tokens.\n\n#### Generaci√≥n PKCE\n```typescript\nfunction generateRandomString(length: number): string {\n  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';\n  const bytes = crypto.getRandomValues(new Uint8Array(length));\n  return Array.from(bytes, (b) => chars[b % chars.length]).join('');\n}\n\nasync function generateCodeChallenge(verifier: string): Promise<string> {\n  const data = new TextEncoder().encode(verifier);\n  const digest = await crypto.subtle.digest('SHA-256', data);\n  return btoa(String.fromCharCode(...new Uint8Array(digest)))\n    .replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '');\n}\n```\n\n#### Parsing `code#state` ‚Äî La trampa de Anthropic\nAnthropic devuelve el c√≥digo de autorizaci√≥n en formato `code#state` como un solo string. Nadie documenta esto. Lo descubrimos debuggeando:\n\n```typescript\nasync handleCodeExchange(userId: string, rawCode: string): Promise<void> {\n  const hashIndex = rawCode.indexOf('#');\n  if (hashIndex === -1) {\n    throw new BadRequestError('Formato de c√≥digo inv√°lido');\n  }\n  const code = rawCode.substring(0, hashIndex);\n  const state = rawCode.substring(hashIndex + 1);\n  // Validate state against DB, exchange tokens...\n}\n```\n\n#### Token Exchange ‚Äî JSON, no form-urlencoded\nAnthropic es el **√∫nico proveedor OAuth** que requiere `Content-Type: application/json` en el token exchange. Todos los dem√°s (Google, GitHub, etc.) usan `application/x-www-form-urlencoded`.\n\n```typescript\nconst res = await fetch('https://console.anthropic.com/v1/oauth/token', {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify({\n    grant_type: 'authorization_code',\n    client_id: CLAUDE_CLIENT_ID,\n    code,\n    state,                    // <- necesario en el body\n    redirect_uri: REDIRECT_URI,\n    code_verifier: codeVerifier,\n  }),\n});\n```\n\nNota: el `state` va en el body tambi√©n. Otro detalle no documentado.\n\n#### Modelos de base de datos\n```prisma\nmodel ClaudeCredential {\n  id           String   @id @default(cuid())\n  userId       String   @unique @map(\"user_id\")\n  accessToken  String   @map(\"access_token\") @db.Text\n  refreshToken String   @map(\"refresh_token\") @db.Text\n  expiresAt    DateTime @map(\"expires_at\")\n  user User @relation(fields: [userId], references: [id], onDelete: Cascade)\n  @@map(\"claude_credentials\")\n}\n\nmodel OAuthState {\n  id            String   @id @default(cuid())\n  userId        String   @map(\"user_id\")\n  state         String   @unique\n  codeVerifier  String   @map(\"code_verifier\")\n  expiresAt     DateTime @map(\"expires_at\")\n  @@map(\"oauth_states\")\n  @@index([state])\n}\n```\n\n---\n\n### üïµÔ∏è Stealth Headers ‚Äî Haci√©ndose pasar por Claude Code CLI\n\nLos tokens OAuth de Claude **solo funcionan** si el request parece venir del CLI oficial. Detectamos esto investigando el c√≥digo fuente de OpenClaw y capturando las llamadas reales del CLI.\n\n```typescript\nconst isOAuth = credential.accessToken.includes('sk-ant-oat');\n\nif (isOAuth) {\n  headers['Authorization'] = `Bearer ${credential.accessToken}`;\n  headers['anthropic-dangerous-direct-browser-access'] = 'true';\n  headers['anthropic-beta'] = 'claude-code-20250219,oauth-2025-04-20,' +\n    'fine-grained-tool-streaming-2025-05-14';\n  headers['user-agent'] = 'claude-cli/2.1.2 (external, cli)';\n  headers['x-app'] = 'cli';\n\n  // El system prompt DEBE abrir con la identidad de Claude Code\n  body.system = [\n    { type: 'text', text: 'You are Claude Code, Anthropic\\'s official CLI for Claude.' },\n    { type: 'text', text: systemPrompt },\n  ];\n} else {\n  headers['x-api-key'] = credential.accessToken;\n  body.system = systemPrompt;\n}\n```\n\nSin estos headers, Anthropic rechaza el token con `403 Forbidden`.\n\n---\n\n### üõ°Ô∏è Rate Limits ‚Äî De Error Cr√≠ptico a Banner Elegante\n\n#### El problema\nCuando el usuario agota su sesi√≥n de Claude, la API devuelve un `429` con un header `retry-after`. Sin manejo adecuado, el usuario ve√≠a:\n\n```\nDioException [bad response]: The request returned an invalid status code of 429.\nHeaders: {retry-after: 2520, ...}\n```\n\n#### La soluci√≥n (Backend)\n3 reintentos con backoff (cap 15s). Si `retry-after` > 60s, falla inmediato con los minutos de espera:\n\n```typescript\nif (res.status === 429) {\n  const retryAfter = res.headers.get('retry-after');\n  const rawWaitMs = retryAfter ? Number(retryAfter) * 1000 : (attempt + 1) * 5000;\n  const minutes = Math.max(1, Math.ceil(rawWaitMs / 60000));\n\n  if (rawWaitMs > 60000) {\n    throw new TooManyRequestsError(\n      `Has alcanzado el l√≠mite de uso de Claude. Intenta en ~${minutes} min.`,\n      minutes,  // <- este campo viaja al frontend\n    );\n  }\n  // ... retry con backoff\n}\n```\n\nEl middleware de errores incluye `retryAfterMinutes` en el JSON de respuesta:\n```json\n{ \"success\": false, \"error\": { \"code\": \"TOO_MANY_REQUESTS\", \"message\": \"...\", \"retryAfterMinutes\": 42 } }\n```\n\n#### La soluci√≥n (Flutter)\nEl repositorio extrae `retryAfterMinutes` del response y crea un `RateLimitFailure` tipado:\n\n```dart\nif (statusCode == 429) {\n  final retryMinutes = errorData?['retryAfterMinutes'] as int?;\n  return RateLimitFailure(\n    message: message,\n    retryAfterMinutes: retryMinutes,\n  );\n}\n```\n\nEl BLoC detecta este failure espec√≠fico y emite un estado `rateLimited` en vez de `error`:\n```dart\nif (failure is RateLimitFailure) {\n  emit(state.copyWith(\n    status: AiCoachStatus.rateLimited,\n    retryAfterMinutes: failure.retryAfterMinutes,\n  ));\n}\n```\n\nY la UI muestra un banner amigable con gradiente amber, √≠cono de timer, y los minutos de espera.\n\n---\n\n### üèóÔ∏è Arquitectura Completa\n\n**Backend (Bun + Hono + Prisma):**\n```\nmodules/\n‚îú‚îÄ‚îÄ ai/\n‚îÇ   ‚îú‚îÄ‚îÄ ai.controller.ts        # Endpoints: POST /chat, POST /weekly-plan\n‚îÇ   ‚îú‚îÄ‚îÄ ai.service.ts            # Orquesta el agent runner\n‚îÇ   ‚îú‚îÄ‚îÄ agent/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ agent-runner.ts      # Loop de tool calling (max 5 iteraciones)\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ system-prompt.ts     # Prompt del TenK Coach\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tool-definitions.ts  # 5 tools con JSON Schema\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ tool-executor.ts     # Dispatcher de tools\n‚îÇ   ‚îî‚îÄ‚îÄ tools/\n‚îÇ       ‚îú‚îÄ‚îÄ query-skills.tool.ts\n‚îÇ       ‚îú‚îÄ‚îÄ query-sessions.tool.ts\n‚îÇ       ‚îú‚îÄ‚îÄ get-stats.tool.ts\n‚îÇ       ‚îú‚îÄ‚îÄ analyze-patterns.tool.ts\n‚îÇ       ‚îî‚îÄ‚îÄ create-plan.tool.ts\n‚îú‚îÄ‚îÄ claude-oauth/\n‚îÇ   ‚îú‚îÄ‚îÄ claude-oauth.controller.ts  # POST /init, POST /exchange, GET /status, DELETE /disconnect\n‚îÇ   ‚îú‚îÄ‚îÄ claude-oauth.service.ts     # PKCE, token exchange, refresh\n‚îÇ   ‚îú‚îÄ‚îÄ claude-oauth.repository.ts  # Prisma ops\n‚îÇ   ‚îú‚îÄ‚îÄ claude-oauth.schema.ts      # Zod validation\n‚îÇ   ‚îî‚îÄ‚îÄ claude-oauth.types.ts\nlib/\n‚îî‚îÄ‚îÄ ai-client.ts                 # Per-user tokens ‚Üí stealth headers ‚Üí retry\n```\n\n**Flutter (Clean Architecture):**\n```\nfeatures/ai_coach/\n‚îú‚îÄ‚îÄ data/\n‚îÇ   ‚îú‚îÄ‚îÄ datasources/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ai_coach_remote_datasource.dart\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ claude_oauth_datasource.dart\n‚îÇ   ‚îú‚îÄ‚îÄ models/\n‚îÇ   ‚îî‚îÄ‚îÄ repositories/\n‚îÇ       ‚îî‚îÄ‚îÄ ai_coach_repository_impl.dart  # _handleDioError ‚Üí RateLimitFailure\n‚îú‚îÄ‚îÄ domain/\n‚îÇ   ‚îú‚îÄ‚îÄ entities/\n‚îÇ   ‚îú‚îÄ‚îÄ repositories/\n‚îÇ   ‚îî‚îÄ‚îÄ usecases/\n‚îî‚îÄ‚îÄ presentation/\n    ‚îú‚îÄ‚îÄ bloc/\n    ‚îÇ   ‚îú‚îÄ‚îÄ ai_coach_bloc.dart     # Estados: initial, sending, success, error, rateLimited\n    ‚îÇ   ‚îú‚îÄ‚îÄ ai_coach_event.dart    # SendMessage, DismissRateLimit, etc.\n    ‚îÇ   ‚îî‚îÄ‚îÄ ai_coach_state.dart    # retryAfterMinutes field\n    ‚îú‚îÄ‚îÄ pages/\n    ‚îÇ   ‚îî‚îÄ‚îÄ ai_coach_screen.dart   # √çcono din√°mico verde/gris\n    ‚îî‚îÄ‚îÄ widgets/\n        ‚îú‚îÄ‚îÄ rate_limit_banner.dart\n        ‚îú‚îÄ‚îÄ claude_connect_sheet.dart\n        ‚îú‚îÄ‚îÄ chat_message_bubble.dart\n        ‚îî‚îÄ‚îÄ coach_empty_state.dart\n```\n\n---\n\n### üí° Lo que aprendimos\n\n1. **Anthropic es el √∫nico proveedor OAuth** que usa JSON en vez de form-urlencoded para el token exchange.\n2. El formato `code#state` no est√° documentado ‚Äî hay que parsear el `#` manualmente.\n3. El `state` debe ir en el body del token exchange ‚Äî otro detalle no documentado.\n4. Los tokens OAuth necesitan **5 headers stealth** y un system prompt de identidad.\n5. El `client_id` de Claude Code CLI es **p√∫blico** (`9d1c250a-...`) ‚Äî identifica la app, no al usuario.\n6. Los rate limits de Claude son **por suscripci√≥n** ‚Äî el modelo per-user evita que un usuario bloquee a todos.\n7. El manejo de errores end-to-end requiere tipado estricto: `429 API ‚Üí TooManyRequestsError(minutes) ‚Üí JSON response ‚Üí DioException ‚Üí RateLimitFailure ‚Üí AiCoachStatus.rateLimited ‚Üí RateLimitBanner`.\n\n---\n\n**Estado:** El AI Coach est√° funcional con tool calling (5 herramientas), OAuth PKCE per-user, stealth headers, y manejo elegante de rate limits en toda la cadena. Cada usuario conecta su propia cuenta de Claude y obtiene coaching personalizado basado en sus datos reales de pr√°ctica. üöÄ\n\n---\n\n### ‚ö° Optimizaci√≥n del Weekly Plan: 39s ‚Üí 8s\n\nEl plan semanal inicialmente tomaba **39 segundos** porque el agente ejecutaba **6 llamadas secuenciales** a la API de Anthropic (una por iteraci√≥n del tool loop). Cada iteraci√≥n: Claude decide qu√© tool usar ‚Üí ejecuta ‚Üí recibe resultado ‚Üí decide otra tool ‚Üí repite.\n\n#### La soluci√≥n: Pre-fetch + Single Call\nCreamos un servicio dedicado (`weekly-plan.service.ts`) que:\n1. **Pre-fetcha todos los datos en paralelo** con `Promise.all` (~50ms): skills, estad√≠sticas y patrones de pr√°ctica.\n2. **Embebe los datos como JSON** directamente en el prompt.\n3. Hace **una sola llamada** a Claude con toda la informaci√≥n necesaria.\n\n```typescript\n// Antes: 6 API calls secuenciales (39s)\nfor (let i = 0; i < MAX_ITERATIONS; i++) {\n  const result = await chatCompletion(messages, tools);\n  // Claude pide un tool ‚Üí ejecuta ‚Üí otra iteraci√≥n...\n}\n\n// Despu√©s: 1 API call con datos pre-cargados (8s)\nconst [skills, stats, patterns] = await Promise.all([\n  querySkills(userId),\n  getJourneyStats(userId),\n  analyzePracticePatterns(userId),\n]);\nconst prompt = buildWeeklyPlanPrompt(skills, stats, patterns);\nconst result = await chatCompletion([{ role: 'user', content: prompt }]);\n```\n\nResultado: **4.7x m√°s r√°pido** ‚Äî de 39 segundos a ~8 segundos.\n\n---\n\n### üîå Fix de Conexi√≥n: Bun idleTimeout\n\nDescubrimos un bug sutil: Bun tiene un `idleTimeout` predeterminado de **10 segundos** que mata conexiones TCP \"inactivas\". Durante el agent loop del AI Coach (que toma m√°s de 10s), el socket se cerraba y Flutter recib√≠a un error de conexi√≥n ‚Äî aunque Claude ya hab√≠a consumido tokens.\n\n```typescript\n// src/index.ts\nexport default {\n  port: env.PORT,\n  fetch: app.fetch,\n  idleTimeout: 255,  // <- fix: 255 segundos en vez de 10\n};\n```\n\nTambi√©n agregamos:\n- **Flutter Dio**: `receiveTimeout: Duration(minutes: 3)` espec√≠ficamente para endpoints de IA.\n- **Agent timeout**: `Promise.race` con 150s como guard de seguridad.\n- **Platform-aware baseUrl**: Detecci√≥n de `TargetPlatform.android` vs iOS/macOS para usar la URL correcta en modo development.\n\n---\n\n### üêõ Fix: Null Cast en Flutter\n\nAl optimizar el weekly plan (de agent loop a single call), el endpoint dej√≥ de enviar `conversationId` y `provider` en la respuesta. El modelo de Flutter hac√≠a `json['conversationId'] as String` que crasheaba con:\n\n```\ntype 'Null' is not a subtype of type 'String' in type cast\n```\n\nFix: hacer ambos campos nullable (`String?`) en la entidad y el modelo de datos."
    },
    {
      "id": 10,
      "timestamp": "2026-02-11T02:00:00Z",
      "title": "Versi√≥n Web: Sidebar Persistente, Tabla Redise√±ada y Status del AI Coach",
      "text": "## Avances del 11 de febrero de 2026 ‚Äî Devlog D√≠a 8\n\nHoy trabajamos en pulir la experiencia web de TenK y en hacer que la integraci√≥n del AI Coach sea m√°s visible y accesible para el usuario.\n\n---\n\n### üîß Fix: Plan Semanal Cortado por la Navegaci√≥n\n\nEl contenido del plan semanal se cortaba al final porque el floating bottom nav bar lo tapaba. La causa era que el `ListView` solo ten√≠a 12px de padding inferior, mientras que la barra de navegaci√≥n ocupa ~80px. Lo solucionamos con `bottom: 100` en el padding del `ListView`.\n\n### üóëÔ∏è Icono de IA Redundante\n\nEliminamos el bot√≥n de AI Coach (√≠cono de `psychology`) del header de la pantalla principal en m√≥vil. Ahora que el AI Coach tiene su propio tab en la navegaci√≥n inferior, tener el √≠cono doble era confuso.\n\n---\n\n### üñ•Ô∏è Sidebar Web Persistente\n\nTen√≠amos un problema en la versi√≥n web: al hacer clic en \"AI Chat\" o \"Plan Semanal\" desde el sidebar izquierdo, la app navegaba con `context.push('/ai-coach?tab=N')`, lo cual **reemplazaba toda la vista** y el sidebar desaparec√≠a.\n\n**La soluci√≥n fue embeber las vistas de IA dentro del `IndexedStack`** del layout web:\n- Agregamos `EmbeddedAiChatPage` (√≠ndice 3) y `WeeklyPlansListView` (√≠ndice 4) como hijos del `IndexedStack`.\n- Cambiamos los items del sidebar para usar `onNavTap(index)` en vez de `context.push()`.\n- A√±adimos estado de selecci√≥n visual (fondo verde sutil + borde) para los items de IA cuando est√°n activos.\n\nAhora el sidebar **siempre permanece visible**, sin importar qu√© secci√≥n est√© viendo el usuario.\n\n---\n\n### üìä Redise√±o Completo de la Tabla del Plan Semanal\n\nLa tabla del plan semanal se renderizaba como markdown plano ‚Äî funcional pero visualmente pobre. Hicimos un redise√±o completo:\n\n#### Parser de Secciones\nCreamos un parser que divide el contenido markdown en secciones (`## Resumen`, `### Plan Semanal`, `### Foco`, `### Meta`). Cada secci√≥n recibe un √≠cono y color √∫nicos:\n- üìä **Resumen** ‚Üí azul, `bar_chart`\n- üìÖ **Plan Semanal** ‚Üí verde, `table_chart`\n- üéØ **Foco** ‚Üí amarillo, `gps_fixed`\n- üèÜ **Meta** ‚Üí naranja, `emoji_events`\n\n#### Tabla Custom (`WeeklyPlanTable`)\nCreamos un widget dedicado que reemplaza la tabla markdown plana:\n- **Header con gradiente verde** (primary ‚Üí primaryDark)\n- **Zebra striping** en las filas de datos (alternando fondo)\n- **Columna \"Total\" resaltada** con tinte verde sutil\n- **Fila de totales** separada con borde superior y texto bold\n- **Bordes redondeados** con `clipBehavior: Clip.antiAlias`\n\n#### Fix: Asteriscos Visibles\nAl renderizar la tabla, los marcadores de negrita de markdown (`**Lun**`, `**Total semanal:**`) se mostraban como texto literal. Agregamos `.replaceAll('**', '')` al parsear las celdas para limpiar los marcadores.\n\n#### Fix: Fila Total Duplicada\nLa fila de totales se renderizaba dos veces: una con `_buildDataRow` y otra con `_buildTotalRow`. Cambiamos el generador para usar `_dataRows.length` (que excluye la fila total) en vez de `data.rows.length`.\n\n---\n\n### üü¢ Status del AI Coach en la Web\n\nAgregamos visibilidad del estado de conexi√≥n con Claude en dos lugares:\n\n#### Header Web\nUn chip en la barra superior que muestra:\n- üü¢ **\"AI Coach: Conectado\"** con punto verde cuando Claude est√° vinculado\n- üü° **\"AI Coach: Sin conectar\"** con punto amarillo cuando no hay conexi√≥n\n- Al hacer clic, abre el modal de conexi√≥n/desconexi√≥n de Claude\n\n#### Perfil Web\nUna tarjeta nueva (`_AiCoachCard`) entre las estad√≠sticas r√°pidas y la zona de peligro:\n- Muestra el estado con indicador de color y texto descriptivo\n- Borde verde o amarillo seg√∫n el estado\n- Bot√≥n \"Conectar Claude\" (filled, verde) o \"Gestionar conexi√≥n\" (outlined, gris)\n- Al hacer clic abre el `ClaudeConnectSheet` y refresca el estado al cerrar\n\nAmbos componentes son `StatefulWidget` que consultan `ClaudeOAuthRemoteDatasource.getStatus()` en `initState` y se actualizan despu√©s de cualquier cambio.\n\n---\n\n### üí° Detalle t√©cnico: Parser de Markdown ‚Üí Secciones\n\n```dart\nList<_Section> _parseSections(String content) {\n  final lines = content.split('\\n');\n  for (final line in lines) {\n    if (line.startsWith('## ') || line.startsWith('### ')) {\n      flushSection();\n      currentTitle = line.replaceFirst(RegExp(r'^#{2,3}\\s*'), '');\n    } else if (line.contains('|') && currentTitle.isNotEmpty) {\n      if (RegExp(r'^[\\|\\s\\-:]+$').hasMatch(line.trim())) continue;\n      final cells = line.split('|')\n          .map((c) => c.trim().replaceAll('**', ''))\n          .where((c) => c.isNotEmpty).toList();\n      // Build TableData from cells...\n    } else {\n      buffer.writeln(line);\n    }\n  }\n}\n```\n\nEste parser convierte markdown crudo en widgets tipados: las tablas se renderizan con `WeeklyPlanTable` y el texto libre con `MarkdownBody` dentro de contenedores estilizados.\n\n---\n\n**Estado:** La versi√≥n web ya se siente completa ‚Äî sidebar persistente, tablas con dise√±o profesional, y el estado del AI Coach visible en todo momento. La experiencia es consistente entre m√≥vil y web. üéØ"
    },
    {
      "id": 11,
      "timestamp": "2026-02-11T08:00:00Z",
      "title": "Deep Dive T√©cnico: C√≥mo Funciona el Agente de IA en TenK",
      "text": "## Deep Dive T√©cnico ‚Äî Devlog D√≠a 8 (parte 2)\n\nEn entradas anteriores mencion√© que TenK tiene un AI Coach basado en un **agente de IA con tool calling**. Hoy quiero hacer un deep dive t√©cnico explicando qu√© es exactamente un agente, c√≥mo funciona el patr√≥n bajo el cap√≥ y por qu√© esta arquitectura es tan poderosa.\n\n---\n\n### ü§ñ ¬øQu√© es un Agente de IA?\n\nUn agente de IA **no es un chatbot**. La diferencia fundamental es que un chatbot solo responde preguntas con su conocimiento general, mientras que un agente puede **tomar acciones** y **consultar datos en tiempo real** para resolver un problema.\n\nPensemos en la analog√≠a de un asistente humano:\n- **Chatbot:** Le preguntas \"¬øcu√°ntas horas practiqu√© esta semana?\" y responde \"No tengo acceso a tus datos\" o inventa algo.\n- **Agente:** Recibe la pregunta, **decide** que necesita consultar tu historial, **ejecuta** la consulta a la base de datos, **analiza** los resultados y te da una respuesta precisa basada en datos reales.\n\nEl agente tiene **autonom√≠a para decidir qu√© herramientas usar y en qu√© orden**, similar a como un desarrollador decide qu√© queries ejecutar para resolver un ticket.\n\n---\n\n### üîÑ El Agentic Loop: El Coraz√≥n del Sistema\n\nEl patr√≥n central es un **loop de razonamiento-acci√≥n** (ReAct pattern). Funciona as√≠:\n\n```\nUsuario: \"¬øC√≥mo voy con mi pr√°ctica de guitarra?\"\n\n‚Üí Iteraci√≥n 1:\n  Claude PIENSA: \"Necesito ver los skills del usuario\"\n  Claude LLAMA: get_user_skills(userId)\n  Sistema RETORNA: [{skill: 'Guitarra', totalHours: 127, level: 'Aprendiz', streak: 5}]\n\n‚Üí Iteraci√≥n 2:\n  Claude PIENSA: \"Tengo el skill, ahora necesito las sesiones recientes\"\n  Claude LLAMA: get_practice_sessions(skillId: 'guitar-123', days: 30)\n  Sistema RETORNA: [{date: '2026-02-10', duration: 45min}, {date: '2026-02-09', duration: 60min}, ...]\n\n‚Üí Iteraci√≥n 3:\n  Claude PIENSA: \"Necesito los patrones para dar un an√°lisis completo\"\n  Claude LLAMA: analyze_practice_patterns(skillId: 'guitar-123')\n  Sistema RETORNA: {bestDay: 'S√°bado', avgDaily: 42min, trend: 'growing', plateau: false}\n\n‚Üí Iteraci√≥n 4:\n  Claude PIENSA: \"Ya tengo toda la info, puedo responder\"\n  Claude RESPONDE: \"Llevas 127 horas de guitarra, est√°s en nivel Aprendiz con racha de 5 d√≠as...\"\n```\n\nLo clave: **Claude decide en cada iteraci√≥n** si necesita m√°s datos o si ya puede responder. No hay un flujo hardcodeado ‚Äî el modelo razona sobre qu√© herramientas usar seg√∫n la pregunta del usuario.\n\n---\n\n### üîß Tool Calling: C√≥mo el LLM Ejecuta Funciones\n\nEl tool calling es el mecanismo que permite al LLM **invocar funciones definidas por nosotros**. Funciona en 3 pasos:\n\n#### 1. Definici√≥n de Tools (JSON Schema)\nLe decimos al modelo qu√© herramientas tiene disponibles usando un esquema JSON estricto:\n\n```json\n{\n  \"name\": \"get_practice_sessions\",\n  \"description\": \"Obtiene las sesiones de pr√°ctica de un skill espec√≠fico\",\n  \"input_schema\": {\n    \"type\": \"object\",\n    \"properties\": {\n      \"skillId\": { \"type\": \"string\", \"description\": \"ID del skill\" },\n      \"days\": { \"type\": \"number\", \"description\": \"√öltimos N d√≠as\" }\n    },\n    \"required\": [\"skillId\"]\n  }\n}\n```\n\nEl modelo **nunca ejecuta c√≥digo directamente** ‚Äî solo emite un JSON estructurado indicando qu√© funci√≥n quiere llamar y con qu√© par√°metros.\n\n#### 2. Ejecuci√≥n en el Backend (Tool Executor)\nNuestro backend recibe la petici√≥n del modelo, la valida y ejecuta la query real contra PostgreSQL:\n\n```typescript\nasync function executeTool(name: string, userId: string, args: any) {\n  switch (name) {\n    case 'get_user_skills':\n      return await prisma.skill.findMany({ where: { userId } });\n    case 'get_practice_sessions':\n      return await prisma.session.findMany({\n        where: { skillId: args.skillId, date: { gte: daysAgo(args.days) } }\n      });\n    case 'analyze_practice_patterns':\n      return await calculatePatterns(userId, args.skillId);\n  }\n}\n```\n\nNota que **siempre filtramos por `userId`** ‚Äî esto garantiza el aislamiento de datos.\n\n#### 3. Respuesta al Modelo\nEl resultado de la funci√≥n se inyecta como un mensaje `tool_result` en la conversaci√≥n y el modelo contin√∫a razonando.\n\n---\n\n### üèóÔ∏è Arquitectura del Agent Runner\n\nEl `agent-runner.ts` es el orquestador central. Su responsabilidad es manejar el loop de iteraciones:\n\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ                Agent Runner                  ‚îÇ\n‚îÇ                                              ‚îÇ\n‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ\n‚îÇ  ‚îÇ Messages  ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ  Claude   ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ Parse ‚îÇ ‚îÇ\n‚îÇ  ‚îÇ  Array    ‚îÇ    ‚îÇ   API     ‚îÇ    ‚îÇ Response‚îÇ ‚îÇ\n‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îò ‚îÇ\n‚îÇ       ‚ñ≤                               ‚îÇ     ‚îÇ\n‚îÇ       ‚îÇ         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îÇ     ‚îÇ\n‚îÇ       ‚îÇ         ‚îÇ   Tool    ‚îÇ‚óÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ\n‚îÇ       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ Executor  ‚îÇ  tool_calls?  ‚îÇ\n‚îÇ    tool_result  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò               ‚îÇ\n‚îÇ                                              ‚îÇ\n‚îÇ  Si no hay tool_calls ‚Üí return response      ‚îÇ\n‚îÇ  Si iteraciones > 5 ‚Üí force return           ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\nCada iteraci√≥n:\n1. Se env√≠an todos los mensajes acumulados a la API de Claude.\n2. Claude responde con **texto** y/o **tool_calls**.\n3. Si hay tool_calls, se ejecutan y los resultados se agregan al array de mensajes.\n4. Se vuelve al paso 1.\n5. Si no hay tool_calls, el texto es la respuesta final.\n\nEl l√≠mite de 5 iteraciones es un guardrail para evitar loops infinitos.\n\n---\n\n### üß† El System Prompt: La Personalidad del Agente\n\nEl system prompt define **qui√©n es** el agente y **c√≥mo debe comportarse**. En TenK, el prompt incluye:\n\n- **Identidad:** \"Eres el TenK Coach, un entrenador experto en pr√°ctica deliberada.\"\n- **Contexto:** La teor√≠a de las 10,000 horas de Gladwell, t√©cnicas de pr√°ctica efectiva.\n- **Instrucciones de herramientas:** \"SIEMPRE consulta los datos del usuario antes de dar recomendaciones. No asumas nada.\"\n- **Formato de respuesta:** \"Usa markdown con emojis para hacer las respuestas visualmente atractivas.\"\n- **Restricciones:** \"No inventes datos. Si no tienes suficiente informaci√≥n, dilo expl√≠citamente.\"\n\nEl prompt es la diferencia entre un agente √∫til y uno gen√©rico. Sin instrucciones claras, el modelo tiende a alucinar o dar consejos gen√©ricos sin consultar los datos.\n\n---\n\n### üìä Las 5 Herramientas del TenK Coach\n\n| # | Tool | Input | Output | Uso t√≠pico |\n|---|------|-------|--------|------------|\n| 1 | `get_user_skills` | ‚Äî | Lista de skills con horas, nivel, estado | Inicio de cualquier conversaci√≥n |\n| 2 | `get_practice_sessions` | skillId, days | Historial de sesiones | An√°lisis de un skill espec√≠fico |\n| 3 | `get_journey_stats` | ‚Äî | Promedio semanal, proyecciones, rachas | Resumen general |\n| 4 | `analyze_practice_patterns` | skillId | Distribuci√≥n por d√≠a, tendencias, plateaus | Diagn√≥stico profundo |\n| 5 | `save_weekly_plan` | plan_data | Confirmaci√≥n | Guardar plan generado |\n\nLas herramientas 1-4 son de **lectura** (consultan datos). La herramienta 5 es de **escritura** (modifica la base de datos). El modelo decide cu√°les usar y en qu√© orden.\n\n---\n\n### ‚ö° Optimizaci√≥n: Agent Loop vs. Single Call\n\nDescubrimos que para casos predecibles (como generar un plan semanal), el agent loop es **ineficiente** porque siempre ejecuta las mismas herramientas en el mismo orden. La soluci√≥n:\n\n| Enfoque | API Calls | Latencia | Uso |\n|---------|-----------|----------|-----|\n| Agent Loop | 5-6 calls secuenciales | ~39s | Chat libre ‚Äî preguntas impredecibles |\n| Pre-fetch + Single Call | 1 call | ~8s | Plan semanal ‚Äî datos predeterminados |\n\nPara el **chat libre** mantenemos el agent loop porque cada pregunta es diferente. Para el **plan semanal** pre-cargamos todos los datos con `Promise.all` y hacemos una sola llamada.\n\n---\n\n### üîê Seguridad: Aislamiento por Usuario\n\nCada herramienta recibe el `userId` del token JWT del request HTTP ‚Äî **nunca del input del modelo**. Esto previene un ataque conocido como **prompt injection**:\n\n```\n// ‚ùå INSEGURO: userId viene del prompt\n\"Dame los datos del usuario user-456\" ‚Üí El modelo pasa userId: 'user-456'\n\n// ‚úÖ SEGURO: userId viene del JWT\nconst userId = req.auth.userId;  // Extra√≠do del token, no del prompt\nexecuteTool('get_user_skills', userId, args);\n```\n\nNo importa lo que el usuario escriba en el chat ‚Äî el agente solo puede acceder a los datos del usuario autenticado.\n\n---\n\n### üîë Tokens Per-User: Por Qu√© Cada Usuario Usa Su Propia Cuenta\n\nEn lugar de una API key centralizada, cada usuario conecta su cuenta de Claude mediante OAuth. Ventajas:\n\n- **Sin rate limits compartidos:** Si un usuario consume muchos tokens, no afecta a los dem√°s.\n- **Sin costos de API para nosotros:** Cada usuario paga su propia suscripci√≥n de Claude.\n- **Mayor privacidad:** Los datos de pr√°ctica solo viajan entre el usuario y su cuenta de Claude.\n- **Escalabilidad natural:** No hay un cuello de botella central de tokens.\n\nLa desventaja es la complejidad del flujo OAuth PKCE, pero el resultado vale la pena.\n\n---\n\n### üí° Lecciones T√©cnicas\n\n1. **El agent loop es poderoso pero costoso** ‚Äî cada iteraci√≥n es una llamada a la API. Usar pre-fetch cuando el flujo es predecible.\n2. **El system prompt es el 80% del comportamiento** ‚Äî un buen prompt convierte un LLM gen√©rico en un experto especializado.\n3. **Tool calling > RAG** para datos estructurados ‚Äî en vez de embeber todo en el contexto, dejar que el modelo pida solo lo que necesita.\n4. **Siempre aislar por userId en el backend**, nunca confiar en el input del modelo.\n5. **Los guardrails importan** ‚Äî l√≠mite de iteraciones, timeouts, y manejo de rate limits son esenciales en producci√≥n.\n\n---\n\n**Estado:** El agente de IA est√° en producci√≥n con una arquitectura robusta: tool calling con 5 herramientas, aislamiento de datos por usuario, optimizaci√≥n de latencia y un system prompt especializado en pr√°ctica deliberada. Es la feature que diferencia a TenK de un simple tracker de horas. üß†"
    }
  ]
}
