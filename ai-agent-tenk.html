<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CÃ³mo ConstruÃ­ un Agente de IA con Tool Calling para TenK | Oscar Code</title>
  <meta name="description" content="Deep dive tÃ©cnico sobre la arquitectura de un agente de IA con tool calling, OAuth PKCE con Claude, y cÃ³mo funciona el patrÃ³n agentic loop en producciÃ³n.">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
  <style>
    :root {
      --primary: #26a69a;
      --primary-dark: #00897b;
      --bg-dark: #0a0a0a;
      --bg-card: #111111;
      --bg-code: #1a1a2e;
      --text-primary: #ffffff;
      --text-secondary: rgba(255,255,255,0.7);
      --text-muted: rgba(255,255,255,0.5);
      --accent-blue: #4fc3f7;
      --accent-purple: #b388ff;
      --accent-orange: #ffab40;
      --accent-red: #ff6b6b;
      --accent-green: #69f0ae;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg-dark);
      color: var(--text-primary);
      line-height: 1.8;
    }

    .container {
      max-width: 860px;
      margin: 0 auto;
      padding: 0 20px;
    }

    /* ========== HEADER ========== */
    .post-header {
      text-align: center;
      padding: 80px 20px 60px;
      background: linear-gradient(135deg, var(--bg-dark) 0%, #1a1a2e 50%, #0d2137 100%);
      border-bottom: 1px solid rgba(255,255,255,0.1);
      position: relative;
      overflow: hidden;
    }

    .post-header::before {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: radial-gradient(circle at 30% 50%, rgba(38,166,154,0.08) 0%, transparent 50%),
                  radial-gradient(circle at 70% 50%, rgba(79,195,247,0.05) 0%, transparent 50%);
      animation: headerGlow 8s ease-in-out infinite alternate;
    }

    @keyframes headerGlow {
      0% { transform: translate(0, 0); }
      100% { transform: translate(-2%, 2%); }
    }

    .back-link {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      color: var(--primary);
      text-decoration: none;
      margin-bottom: 30px;
      transition: all 0.3s;
      position: relative;
      z-index: 1;
    }

    .back-link:hover {
      color: var(--primary-dark);
      transform: translateX(-5px);
    }

    .post-title {
      font-size: 2.5em;
      margin-bottom: 15px;
      background: linear-gradient(135deg, var(--primary) 0%, var(--accent-blue) 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      position: relative;
      z-index: 1;
    }

    .post-subtitle {
      font-size: 1.2em;
      color: var(--text-secondary);
      margin-bottom: 25px;
      position: relative;
      z-index: 1;
    }

    .post-meta {
      color: var(--text-muted);
      font-size: 0.95em;
      position: relative;
      z-index: 1;
    }

    .post-tag {
      display: inline-block;
      background: var(--primary);
      color: white;
      padding: 4px 12px;
      border-radius: 20px;
      font-size: 0.8em;
      margin-right: 8px;
    }

    .post-tag.ai { background: var(--accent-purple); }
    .post-tag.backend { background: var(--accent-blue); color: #000; }
    .post-tag.security { background: var(--accent-orange); color: #000; }

    /* ========== CONTENT ========== */
    .post-content {
      padding: 60px 0 80px;
    }

    .post-content h2 {
      font-size: 1.8em;
      margin: 60px 0 25px;
      color: var(--primary);
      border-bottom: 2px solid rgba(38,166,154,0.3);
      padding-bottom: 10px;
    }

    .post-content h2:first-child {
      margin-top: 0;
    }

    .post-content h3 {
      font-size: 1.35em;
      margin: 40px 0 15px;
      color: var(--accent-blue);
    }

    .post-content h4 {
      font-size: 1.1em;
      margin: 25px 0 10px;
      color: var(--accent-green);
    }

    .post-content p {
      margin-bottom: 18px;
      color: var(--text-secondary);
    }

    .post-content strong {
      color: var(--text-primary);
    }

    .post-content a {
      color: var(--primary);
      text-decoration: none;
      border-bottom: 1px solid transparent;
      transition: border-color 0.3s;
    }

    .post-content a:hover {
      border-bottom-color: var(--primary);
    }

    .post-content ul, .post-content ol {
      margin: 15px 0 20px 25px;
      color: var(--text-secondary);
    }

    .post-content li {
      margin-bottom: 8px;
    }

    .post-content code {
      background: rgba(38,166,154,0.15);
      color: var(--primary);
      padding: 2px 7px;
      border-radius: 4px;
      font-family: 'Fira Code', 'JetBrains Mono', monospace;
      font-size: 0.9em;
    }

    .post-content pre {
      background: var(--bg-code);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 12px;
      padding: 25px;
      margin: 20px 0 25px;
      overflow-x: auto;
      position: relative;
    }

    .post-content pre code {
      background: none;
      color: #e0e0e0;
      padding: 0;
      font-size: 0.88em;
      line-height: 1.6;
    }

    .code-label {
      position: absolute;
      top: 8px;
      right: 12px;
      font-size: 0.7em;
      color: var(--text-muted);
      font-family: 'Fira Code', monospace;
      background: rgba(255,255,255,0.05);
      padding: 2px 8px;
      border-radius: 4px;
    }

    /* Callout boxes */
    .callout {
      border-left: 4px solid var(--primary);
      background: var(--bg-card);
      padding: 20px 25px;
      margin: 25px 0;
      border-radius: 0 10px 10px 0;
    }

    .callout.warning {
      border-left-color: var(--accent-orange);
    }

    .callout.danger {
      border-left-color: var(--accent-red);
    }

    .callout.info {
      border-left-color: var(--accent-blue);
    }

    .callout p {
      margin-bottom: 0;
    }

    .callout p:not(:last-child) {
      margin-bottom: 10px;
    }

    /* Diagrams / ASCII art */
    .diagram {
      background: var(--bg-code);
      border: 1px solid rgba(38,166,154,0.2);
      border-radius: 12px;
      padding: 30px;
      margin: 25px 0;
      overflow-x: auto;
      text-align: center;
    }

    .diagram pre {
      background: none;
      border: none;
      padding: 0;
      margin: 0;
      display: inline-block;
      text-align: left;
    }

    .diagram pre code {
      color: var(--primary);
      font-size: 0.82em;
    }

    .diagram-caption {
      margin-top: 12px;
      font-size: 0.85em;
      color: var(--text-muted);
      font-style: italic;
    }

    /* Tables */
    .post-content table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0 25px;
      font-size: 0.92em;
    }

    .post-content th {
      background: rgba(38,166,154,0.15);
      color: var(--primary);
      padding: 12px 15px;
      text-align: left;
      border-bottom: 2px solid rgba(38,166,154,0.3);
    }

    .post-content td {
      padding: 10px 15px;
      border-bottom: 1px solid rgba(255,255,255,0.06);
      color: var(--text-secondary);
    }

    .post-content tr:hover td {
      background: rgba(255,255,255,0.02);
    }

    /* Comparison boxes */
    .comparison {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin: 25px 0;
    }

    .comparison-box {
      background: var(--bg-card);
      border-radius: 12px;
      padding: 22px;
      border: 1px solid rgba(255,255,255,0.08);
    }

    .comparison-box.bad {
      border-color: rgba(255,107,107,0.3);
    }

    .comparison-box.good {
      border-color: rgba(38,166,154,0.3);
    }

    .comparison-box h4 {
      margin-top: 0;
      margin-bottom: 10px;
    }

    .comparison-box.bad h4 { color: var(--accent-red); }
    .comparison-box.good h4 { color: var(--accent-green); }

    /* Section numbers */
    .section-number {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 36px;
      height: 36px;
      background: var(--primary);
      color: white;
      border-radius: 50%;
      font-weight: bold;
      font-size: 0.9em;
      margin-right: 12px;
    }

    /* Key takeaways */
    .takeaways {
      background: linear-gradient(135deg, rgba(38,166,154,0.1) 0%, rgba(79,195,247,0.05) 100%);
      border: 1px solid rgba(38,166,154,0.2);
      border-radius: 16px;
      padding: 30px;
      margin: 40px 0;
    }

    .takeaways h3 {
      color: var(--primary);
      margin-top: 0;
    }

    .takeaways ol {
      color: var(--text-secondary);
    }

    .takeaways li {
      margin-bottom: 12px;
    }

    /* Images */
    .post-image {
      margin: 30px 0;
      text-align: center;
    }

    .post-image img {
      max-width: 100%;
      border-radius: 16px;
      border: 2px solid rgba(255,255,255,0.1);
      box-shadow: 0 10px 40px rgba(0,0,0,0.5);
    }

    .post-image figcaption {
      margin-top: 12px;
      font-size: 0.85em;
      color: var(--text-muted);
      font-style: italic;
    }

    .post-gallery {
      display: flex;
      gap: 16px;
      justify-content: center;
      flex-wrap: wrap;
      margin: 30px 0;
    }

    .post-gallery img {
      max-width: 260px;
      border-radius: 16px;
      border: 2px solid rgba(255,255,255,0.1);
      box-shadow: 0 10px 40px rgba(0,0,0,0.5);
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }

    .post-gallery img:hover {
      transform: scale(1.03);
      box-shadow: 0 15px 50px rgba(38,166,154,0.2);
      border-color: var(--primary);
    }

    /* Footer */
    .post-footer {
      text-align: center;
      padding: 60px 20px;
      border-top: 1px solid rgba(255,255,255,0.1);
      margin-top: 60px;
    }

    .post-footer a {
      color: var(--primary);
      text-decoration: none;
    }

    /* Responsive */
    @media (max-width: 768px) {
      .post-title { font-size: 1.7em; }
      .post-header { padding: 60px 15px 40px; }
      .comparison { grid-template-columns: 1fr; }
      .post-content pre { padding: 15px; }
      .post-content h2 { font-size: 1.4em; }
    }
  </style>
</head>
<body>

  <!-- HEADER -->
  <header class="post-header">
    <div class="container">
      <a href="index.html" class="back-link">
        <i class="fas fa-arrow-left"></i> Volver al inicio
      </a>
      <h1 class="post-title">CÃ³mo ConstruÃ­ un Agente de IA con Tool Calling</h1>
      <p class="post-subtitle">Arquitectura completa de un AI Coach con Claude, OAuth PKCE y herramientas en producciÃ³n</p>
      <div class="post-meta">
        <span class="post-tag ai">IA / Agentes</span>
        <span class="post-tag backend">Backend</span>
        <span class="post-tag security">OAuth</span>
        <span class="post-tag">Tool Calling</span>
        <br><br>
        <i class="far fa-clock"></i> 11 de febrero de 2026 &nbsp;|&nbsp;
        <i class="far fa-user"></i> Oscar MartÃ­nez &nbsp;|&nbsp;
        <i class="far fa-clock"></i> ~20 min de lectura
      </div>
    </div>
  </header>

  <!-- CONTENT -->
  <main class="post-content">
    <div class="container">

      <!-- INTRO -->
      <div class="callout info">
        <p><strong>TL;DR:</strong> ConstruÃ­ un agente de IA para <a href="https://tenk.oventlabs.com">TenK</a> (app de 10,000 horas) que analiza tus datos de prÃ¡ctica y te da coaching personalizado. Usa <strong>tool calling</strong> con 5 herramientas, <strong>OAuth PKCE</strong> para que cada usuario conecte su cuenta de Claude, y un <strong>agentic loop</strong> de hasta 5 iteraciones. Este post explica cÃ³mo funciona todo bajo el capÃ³.</p>
      </div>

      <!-- ==================== SECCIÃ“N 1 ==================== -->
      <h2><span class="section-number">1</span> Â¿QuÃ© es un Agente de IA?</h2>

      <p>Un agente de IA <strong>no es un chatbot</strong>. La diferencia fundamental es que un chatbot solo responde preguntas con su conocimiento general, mientras que un agente puede <strong>tomar acciones</strong> y <strong>consultar datos en tiempo real</strong> para resolver un problema.</p>

      <p>Pensemos en una analogÃ­a simple:</p>

      <div class="comparison">
        <div class="comparison-box bad">
          <h4>ğŸ¤– Chatbot</h4>
          <p>Le preguntas "Â¿cuÃ¡ntas horas practiquÃ© esta semana?" y responde <em>"No tengo acceso a tus datos"</em> o inventa algo.</p>
        </div>
        <div class="comparison-box good">
          <h4>ğŸ§  Agente</h4>
          <p>Recibe la pregunta, <strong>decide</strong> que necesita consultar tu historial, <strong>ejecuta</strong> la consulta a la base de datos, <strong>analiza</strong> los resultados y responde con datos reales.</p>
        </div>
      </div>

      <p>El agente tiene <strong>autonomÃ­a para decidir quÃ© herramientas usar y en quÃ© orden</strong>, similar a como un desarrollador decide quÃ© queries ejecutar para resolver un ticket. No hay un flujo hardcodeado â€” el modelo razona en cada paso.</p>


      <!-- ==================== SECCIÃ“N 2 ==================== -->
      <h2><span class="section-number">2</span> El Agentic Loop: El CorazÃ³n del Sistema</h2>

      <p>El patrÃ³n central es un <strong>loop de razonamiento-acciÃ³n</strong> (conocido como ReAct pattern). Veamos un ejemplo real de cÃ³mo funciona en TenK:</p>

      <div class="diagram">
        <pre><code>Usuario: "Â¿CÃ³mo voy con mi prÃ¡ctica de guitarra?"

â†’ IteraciÃ³n 1:
  Claude PIENSA: "Necesito ver los skills del usuario"
  Claude LLAMA: get_user_skills(userId)
  Sistema RETORNA: [{skill: 'Guitarra', hours: 127, level: 'Aprendiz'}]

â†’ IteraciÃ³n 2:
  Claude PIENSA: "Necesito las sesiones recientes"
  Claude LLAMA: get_practice_sessions(skillId, days: 30)
  Sistema RETORNA: [{date: '2026-02-10', duration: 45min}, ...]

â†’ IteraciÃ³n 3:
  Claude PIENSA: "Quiero analizar patrones"
  Claude LLAMA: analyze_practice_patterns(skillId)
  Sistema RETORNA: {bestDay: 'SÃ¡bado', trend: 'growing', plateau: false}

â†’ IteraciÃ³n 4:
  Claude PIENSA: "Ya tengo toda la info, puedo responder"
  Claude RESPONDE: "Llevas 127h de guitarra, nivel Aprendiz, racha de 5 dÃ­as..."</code></pre>
        <p class="diagram-caption">Flujo real del agente: 4 iteraciones de razonamiento-acciÃ³n</p>
      </div>

      <p>Lo clave: <strong>Claude decide en cada iteraciÃ³n</strong> si necesita mÃ¡s datos o si ya puede responder. El modelo razona sobre quÃ© herramientas usar segÃºn la pregunta del usuario.</p>


      <!-- ==================== SECCIÃ“N 3 ==================== -->
      <h2><span class="section-number">3</span> Tool Calling: CÃ³mo el LLM Ejecuta Funciones</h2>

      <p>El tool calling es el mecanismo que permite al LLM <strong>invocar funciones definidas por nosotros</strong>. Funciona en 3 pasos:</p>

      <h3>Paso 1: DefiniciÃ³n de Tools (JSON Schema)</h3>

      <p>Le decimos al modelo quÃ© herramientas tiene disponibles. El modelo <strong>nunca ejecuta cÃ³digo</strong> â€” solo emite un JSON estructurado indicando quÃ© funciÃ³n quiere llamar:</p>

      <pre><code>{
  "name": "get_practice_sessions",
  "description": "Obtiene las sesiones de prÃ¡ctica de un skill especÃ­fico",
  "input_schema": {
    "type": "object",
    "properties": {
      "skillId": { "type": "string", "description": "ID del skill" },
      "days":    { "type": "number", "description": "Ãšltimos N dÃ­as", "default": 30 }
    },
    "required": ["skillId"]
  }
}</code></pre>

      <h3>Paso 2: EjecuciÃ³n en el Backend (Tool Executor)</h3>

      <p>Nuestro backend recibe la peticiÃ³n del modelo, valida los parÃ¡metros y ejecuta la query real contra PostgreSQL. Usamos un patrÃ³n <code>TOOL_MAP</code> que mapea nombres de herramientas a funciones importadas, envolviendo todo en try/catch con resultados tipados:</p>

      <pre><code>// tool-executor.ts â€” ImplementaciÃ³n real
import { getUserSkills } from '../tools/query-skills.tool';
import { getPracticeSessions } from '../tools/query-sessions.tool';
import { getJourneyStats } from '../tools/get-stats.tool';
import { analyzePracticePatterns } from '../tools/analyze-patterns.tool';
import { saveWeeklyPlan } from '../tools/create-plan.tool';

type TToolFn = (userId: string, args: Record&lt;string, unknown&gt;) =&gt; Promise&lt;TAgentToolResult&gt;;

const TOOL_MAP: Record&lt;string, TToolFn&gt; = {
  get_user_skills: getUserSkills,
  get_practice_sessions: getPracticeSessions,
  get_journey_stats: getJourneyStats,
  analyze_practice_patterns: analyzePracticePatterns,
  save_weekly_plan: saveWeeklyPlan,
};

export async function executeTool(
  name: string, userId: string, args: Record&lt;string, unknown&gt;,
): Promise&lt;TAgentToolResult&gt; {
  const toolFn = TOOL_MAP[name];
  if (!toolFn) return { success: false, data: null, error: `Unknown tool: ${name}` };
  try {
    return await toolFn(userId, args);
  } catch (error) {
    return { success: false, data: null, error: String(error) };
  }
}</code></pre>

      <p>El tipo <code>TAgentToolResult</code> estandariza la respuesta: <code>{ success: boolean, data: unknown, error?: string }</code>. Esto evita que un error en una herramienta crashee todo el loop â€” el agente recibe el error como dato y puede decidir quÃ© hacer (reintentar, usar otra herramienta, o avisar al usuario).</p>

      <div class="callout warning">
        <p><strong>âš ï¸ Nota de seguridad:</strong> Siempre filtramos por <code>userId</code> extraÃ­do del JWT â€” <strong>nunca del input del modelo</strong>. Esto previene ataques de prompt injection donde un usuario intente acceder a datos ajenos.</p>
      </div>

      <h3>Paso 3: Respuesta al Modelo</h3>

      <p>El resultado de la funciÃ³n se inyecta como un mensaje <code>tool_result</code> en la conversaciÃ³n y el modelo continÃºa razonando con los datos reales.</p>


      <!-- ==================== SECCIÃ“N 4 ==================== -->
      <h2><span class="section-number">4</span> Arquitectura del Agent Runner</h2>

      <p>El <code>agent-runner.ts</code> es el orquestador central. Su responsabilidad es manejar el loop de iteraciones:</p>

      <div class="diagram">
        <pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  AGENT RUNNER                     â”‚
â”‚                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Messages  â”‚â”€â”€â–¶â”‚  Claude  â”‚â”€â”€â–¶â”‚   Parse     â”‚ â”‚
â”‚  â”‚   Array    â”‚    â”‚   API    â”‚    â”‚  Response   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚       â–²                                  â”‚        â”‚
â”‚       â”‚          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚        â”‚
â”‚       â”‚          â”‚   Tool   â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚ Executor â”‚   tool_calls?       â”‚
â”‚     tool_result  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                     â”‚
â”‚                                                   â”‚
â”‚  Si no hay tool_calls â†’ return response           â”‚
â”‚  Si iteraciones > 5  â†’ force return               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>
        <p class="diagram-caption">Arquitectura del Agent Runner con loop de mÃ¡ximo 5 iteraciones</p>
      </div>

      <p>La implementaciÃ³n real en TypeScript. Nota los detalles que no aparecen en tutoriales: <code>Promise.race</code> para timeout global, tracking de tokens consumidos, y una llamada final SIN herramientas cuando se alcanza el lÃ­mite de iteraciones para forzar una respuesta de texto:</p>

      <pre><code>// agent-runner.ts â€” ImplementaciÃ³n real con timeout y tracking
const MAX_TOOL_ITERATIONS = 5;
const AGENT_TIMEOUT_MS = 150_000; // 2.5 minutos mÃ¡ximo total

export async function runAgent(userId: string, messages: IChatMessage[]) {
  // Timeout global â€” Promise.race mata el proceso si tarda mucho
  return Promise.race([
    runAgentLoop(userId, messages),
    agentTimeout(),
  ]);
}

async function agentTimeout(): Promise&lt;never&gt; {
  await new Promise((r) =&gt; setTimeout(r, AGENT_TIMEOUT_MS));
  throw new Error('El agente tardÃ³ demasiado. Intenta de nuevo.');
}

async function runAgentLoop(userId: string, messages: IChatMessage[]) {
  const toolsUsed: string[] = [];
  let lastProvider = 'unknown';
  const totalUsage = { inputTokens: 0, outputTokens: 0 };

  for (let i = 0; i &lt; MAX_TOOL_ITERATIONS; i++) {
    const result = await chatCompletion(messages, AGENT_TOOLS, userId);
    lastProvider = result.provider;

    // Acumular tokens consumidos en cada iteraciÃ³n
    if (result.usage) {
      totalUsage.inputTokens += result.usage.inputTokens;
      totalUsage.outputTokens += result.usage.outputTokens;
    }

    // Sin tool_calls = respuesta final
    if (!result.toolCalls.length) {
      return { response: result.content, toolsUsed, provider: lastProvider, usage: totalUsage };
    }

    // Agregar respuesta del asistente con tool_calls al historial
    messages.push({
      role: 'assistant', content: result.content ?? '',
      tool_calls: result.toolCalls,
    });

    // Ejecutar las herramientas y agregar resultados
    for (const tc of result.toolCalls) {
      const args = JSON.parse(tc.function.arguments);
      const toolResult = await executeTool(tc.function.name, userId, args);
      messages.push({
        role: 'tool',
        content: JSON.stringify(toolResult),
        tool_call_id: tc.id,
      });
      toolsUsed.push(tc.function.name);
    }
  }

  // Guardrail: max iteraciones alcanzado â†’ una llamada final SIN tools
  // Esto fuerza al modelo a generar texto en vez de pedir mÃ¡s tools
  const finalResult = await chatCompletion(messages, undefined, userId);
  if (finalResult.usage) {
    totalUsage.inputTokens += finalResult.usage.inputTokens;
    totalUsage.outputTokens += finalResult.usage.outputTokens;
  }
  return {
    response: finalResult.content ?? 'No pude completar el anÃ¡lisis.',
    toolsUsed, provider: lastProvider, usage: totalUsage,
  };
}</code></pre>

      <div class="callout info">
        <p><strong>ğŸ’¡ Detalle clave:</strong> Cuando el agente alcanza el mÃ¡ximo de 5 iteraciones, la mayorÃ­a de implementaciones simplemente devuelven el Ãºltimo contenido. Nosotros hacemos una <strong>llamada extra sin herramientas</strong> â€” esto obliga a Claude a sintetizar toda la informaciÃ³n recopilada en una respuesta coherente, en vez de cortarse a mitad de un razonamiento.</p>
      </div>

      <p>El array de <code>messages</code> crece con cada iteraciÃ³n: pregunta del usuario â†’ respuesta con tool_calls â†’ resultados de las tools â†’ nueva respuesta â†’ etc. Claude tiene <strong>contexto completo</strong> de toda la conversaciÃ³n para generar la respuesta final.</p>


      <!-- ==================== SECCIÃ“N 5 ==================== -->
      <h2><span class="section-number">5</span> Las 5 Herramientas del TenK Coach</h2>

      <table>
        <thead>
          <tr>
            <th>#</th>
            <th>Tool</th>
            <th>Input</th>
            <th>Output</th>
            <th>Uso tÃ­pico</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>1</td>
            <td><code>get_user_skills</code></td>
            <td><code>includeArchived?: boolean</code></td>
            <td>Skills con horas, emoji, color, nivel de maestrÃ­a, sesiones</td>
            <td>Inicio de conversaciÃ³n</td>
          </tr>
          <tr>
            <td>2</td>
            <td><code>get_practice_sessions</code></td>
            <td><code>skillId</code> (required), <code>days</code> (default: 30)</td>
            <td>Historial de sesiones con fecha, horas, notas</td>
            <td>AnÃ¡lisis de skill especÃ­fico</td>
          </tr>
          <tr>
            <td>3</td>
            <td><code>get_journey_stats</code></td>
            <td>â€”</td>
            <td>Promedio semanal, mejor dÃ­a/semana, proyecciones, rachas</td>
            <td>Resumen general del journey</td>
          </tr>
          <tr>
            <td>4</td>
            <td><code>analyze_practice_patterns</code></td>
            <td><code>skillId?: string</code></td>
            <td>DistribuciÃ³n por dÃ­a, tendencia semanal, gaps, consistencia</td>
            <td>DiagnÃ³stico profundo de hÃ¡bitos</td>
          </tr>
          <tr>
            <td>5</td>
            <td><code>save_weekly_plan</code></td>
            <td><code>content</code> + <code>insights[]</code> (typed)</td>
            <td>ConfirmaciÃ³n + fecha de la semana</td>
            <td>Persistir plan generado</td>
          </tr>
        </tbody>
      </table>

      <p>Las herramientas 1-4 son de <strong>lectura</strong> (consultan datos). La herramienta 5 es de <strong>escritura</strong> (modifica la base de datos). El modelo decide cuÃ¡les usar y en quÃ© orden segÃºn la pregunta del usuario.</p>

      <h3>El Schema de los Insights (Tool #5)</h3>

      <p>La herramienta <code>save_weekly_plan</code> recibe un array de insights tipados â€” no es un string libre, sino datos estructurados que el modelo debe generar siguiendo un schema estricto:</p>

      <pre><code>// La definiciÃ³n real del tool le dice a Claude exactamente quÃ© estructura generar
"insights": {
  "type": "array",
  "items": {
    "type": "object",
    "properties": {
      "type": {
        "type": "string",
        "enum": ["progress", "plateau", "streak", "suggestion", "milestone"]
      },
      "title": { "type": "string" },
      "description": { "type": "string" },
      "skillId": { "type": "string", "description": "Optional skill reference" }
    },
    "required": ["type", "title", "description"]
  }
}</code></pre>

      <p>Esto le da al modelo un vocabulario tipado para clasificar sus observaciones. Cada insight tiene un <code>type</code> semÃ¡ntico que permite renderizar diferentes estilos en el UI (badges de color, iconos, etc.).</p>

      <div class="callout">
        <p><strong>ğŸ’¡ DecisiÃ³n de diseÃ±o:</strong> Las herramientas son <em>granulares a propÃ³sito</em>. PodrÃ­amos haber creado una sola herramienta <code>get_all_data</code> que devuelva todo, pero eso enviarÃ­a datos innecesarios en cada consulta. Con herramientas granulares, Claude solo pide lo que necesita â€” consumiendo menos tokens y reduciendo la latencia.</p>
      </div>


      <!-- ==================== SECCIÃ“N 6 ==================== -->
      <h2><span class="section-number">6</span> El System Prompt: La Personalidad del Agente</h2>

      <p>El system prompt define <strong>quiÃ©n es</strong> el agente y <strong>cÃ³mo debe comportarse</strong>. Es probablemente el componente mÃ¡s importante â€” la diferencia entre un agente Ãºtil y uno genÃ©rico.</p>

      <p>Nuestro prompt incluye reglas muy especÃ­ficas que hacen la diferencia entre un chatbot genÃ©rico y un coach especializado:</p>

      <ul>
        <li><strong>Identidad:</strong> "Eres el TenK Coach, un entrenador experto en prÃ¡ctica deliberada."</li>
        <li><strong>Personalidad:</strong> Motivador pero realista, directo, basado en datos, siempre en espaÃ±ol.</li>
        <li><strong>Parallel tool calling:</strong> "Llama TODAS las herramientas que necesites en una sola respuesta" â€” reduce iteraciones.</li>
        <li><strong>Niveles de maestrÃ­a:</strong> 5 niveles con emojis y rangos de horas exactos.</li>
        <li><strong>Formato de plan semanal:</strong> 4 secciones obligatorias con estructura definida.</li>
        <li><strong>Restricciones:</strong> MÃ¡ximo 300 palabras, nunca inventar datos, no usar fuentes externas.</li>
      </ul>

      <p>Sin instrucciones claras, el modelo tiende a <strong>alucinar</strong> â€” decir "llevas X horas" sin verificar. El prompt fuerza al agente a siempre consultar herramientas primero.</p>

      <pre><code>// system-prompt.ts â€” ImplementaciÃ³n real
export function buildSystemPrompt(): string {
  return `Eres el **TenK Coach** â€” entrenador de prÃ¡ctica deliberada basado en la 
regla de las 10,000 horas.

PERSONALIDAD:
- Motivador pero realista. Si el usuario no practica, dilo con tacto.
- Directo y conciso. Sin rodeos.
- Basado en datos. SIEMPRE usa las herramientas antes de opinar.
- Responde SIEMPRE en espaÃ±ol.

HERRAMIENTAS:
- Llama TODAS las herramientas que necesites en UNA sola respuesta.
- NUNCA inventes estadÃ­sticas. Si no tienes datos, pÃ­delos con las tools.

NIVELES DE MAESTRÃA:
ğŸŒ± Semilla (0-100h) â€” Apenas comenzando
ğŸ“˜ Aprendiz (100-500h) â€” Fundamentos sÃ³lidos
âš¡ Intermedio (500-2,000h) â€” Competencia real
ğŸ”¥ Avanzado (2,000-5,000h) â€” Dominio profundo
ğŸ‘‘ Master (5,000-10,000h) â€” Ã‰lite

PLAN SEMANAL (cuando lo pidan):
1. ğŸ“Š Resumen â€” datos clave de la semana anterior
2. ğŸ“… Plan â€” quÃ© skill, quÃ© dÃ­a, cuÃ¡ntas horas
3. ğŸ¯ Foco â€” 1 recomendaciÃ³n basada en patrones
4. ğŸ† Meta â€” horas objetivo realistas

REGLAS:
- MÃ¡ximo 300 palabras por respuesta
- Reconoce logros: rachas, sesiones largas, nuevos niveles
- No uses fuentes externas, solo los datos del usuario
`;
}</code></pre>

      <h3>El Truco del Parallel Tool Calling</h3>

      <p>La instrucciÃ³n <em>"Llama TODAS las herramientas que necesites en una sola respuesta"</em> es clave para la performance. Sin ella, Claude pide una herramienta por iteraciÃ³n (3-4 API calls). Con ella, Claude puede pedir <code>get_user_skills</code>, <code>get_journey_stats</code> y <code>analyze_practice_patterns</code> en un solo turno â€” reduciendo las iteraciones de 4 a 2.</p>


      <!-- ==================== SECCIÃ“N 7 ==================== -->
      <h2><span class="section-number">7</span> OAuth PKCE: Cada Usuario, Su Propia Cuenta</h2>

      <p>En lugar de usar una API key centralizada (que comparte rate limits entre todos los usuarios), implementamos <strong>OAuth PKCE</strong> donde cada usuario conecta su propia cuenta de Claude Pro o Max.</p>

      <h3>Â¿Por quÃ© Per-User?</h3>

      <div class="comparison">
        <div class="comparison-box bad">
          <h4>âŒ API Key Centralizada</h4>
          <ul>
            <li>Rate limits compartidos entre todos</li>
            <li>Costo de API para nosotros</li>
            <li>Un usuario heavy bloquea a todos</li>
            <li>Escalabilidad limitada</li>
          </ul>
        </div>
        <div class="comparison-box good">
          <h4>âœ… OAuth Per-User</h4>
          <ul>
            <li>Rate limits individuales</li>
            <li>Zero API cost para nosotros</li>
            <li>Cada usuario tiene su cuota</li>
            <li>Escalabilidad natural</li>
          </ul>
        </div>
      </div>

      <h3>El Flujo Completo</h3>

      <div class="diagram">
        <pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Flutter â”‚     â”‚  Backend â”‚     â”‚ Anthropicâ”‚     â”‚  Browser  â”‚
â”‚   App    â”‚     â”‚   API    â”‚     â”‚  OAuth   â”‚     â”‚  (Login)  â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
     â”‚                â”‚                â”‚                  â”‚
     â”‚ 1. Init OAuth  â”‚                â”‚                  â”‚
     â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚                â”‚                  â”‚
     â”‚                â”‚                â”‚                  â”‚
     â”‚                â”‚ 2. Generate    â”‚                  â”‚
     â”‚                â”‚ code_verifier  â”‚                  â”‚
     â”‚                â”‚ + code_challenge                  â”‚
     â”‚                â”‚ (SHA-256)      â”‚                  â”‚
     â”‚                â”‚                â”‚                  â”‚
     â”‚  3. Auth URL   â”‚                â”‚                  â”‚
     â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚                â”‚                  â”‚
     â”‚                â”‚                â”‚                  â”‚
     â”‚ 4. Open browserâ”‚                â”‚                  â”‚
     â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶
     â”‚                â”‚                â”‚    5. User logs  â”‚
     â”‚                â”‚                â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
     â”‚                â”‚                â”‚                  â”‚
     â”‚                â”‚                â”‚  6. code#state   â”‚
     â”‚  7. Paste code â”‚                â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚
     â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
     â”‚                â”‚                â”‚                  â”‚
     â”‚ 8. Exchange    â”‚                â”‚                  â”‚
     â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚                â”‚                  â”‚
     â”‚                â”‚ 9. POST /token â”‚                  â”‚
     â”‚                â”‚ (JSON!)        â”‚                  â”‚
     â”‚                â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚                  â”‚
     â”‚                â”‚                â”‚                  â”‚
     â”‚                â”‚ 10. Tokens     â”‚                  â”‚
     â”‚                â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚                  â”‚
     â”‚                â”‚                â”‚                  â”‚
     â”‚  11. Connected â”‚                â”‚                  â”‚
     â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚                â”‚                  â”‚
     â”‚                â”‚                â”‚                  â”‚</code></pre>
        <p class="diagram-caption">Flujo OAuth PKCE completo: de la app al token</p>
      </div>

      <h3>PKCE: Proof Key for Code Exchange</h3>

      <p>PKCE resuelve el problema de seguridad de OAuth en apps mÃ³viles (donde no puedes guardar un <code>client_secret</code> de forma segura). En vez de un secreto estÃ¡tico, cada flujo genera un par criptogrÃ¡fico Ãºnico:</p>

      <pre><code>// claude-oauth.service.ts

// 1. Generar un string aleatorio de 64 caracteres
function generateRandomString(length: number): string {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';
  const bytes = crypto.getRandomValues(new Uint8Array(length));
  return Array.from(bytes, (b) => chars[b % chars.length]).join('');
}

// 2. Derivar el challenge con SHA-256
async function generateCodeChallenge(verifier: string): Promise&lt;string&gt; {
  const data = new TextEncoder().encode(verifier);
  const digest = await crypto.subtle.digest('SHA-256', data);
  return btoa(String.fromCharCode(...new Uint8Array(digest)))
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
    .replace(/=+$/, '');
}

// El verifier se guarda en DB, el challenge va en la URL de auth
const codeVerifier = generateRandomString(64);
const codeChallenge = await generateCodeChallenge(codeVerifier);</code></pre>

      <p>El <code>code_challenge</code> viaja en la URL de autorizaciÃ³n (pÃºblico). El <code>code_verifier</code> se guarda en nuestra base de datos y se envÃ­a en el token exchange. El servidor de Anthropic verifica que <code>SHA-256(verifier) === challenge</code> â€” si no coincide, rechaza el request.</p>

      <h3>Las Trampas de Anthropic que Nadie Documenta</h3>

      <div class="callout danger">
        <p><strong>ğŸ”¥ Detalle #1:</strong> Anthropic devuelve el cÃ³digo de autorizaciÃ³n en formato <code>code#state</code> como un solo string. Hay que parsear el <code>#</code> manualmente:</p>
      </div>

      <pre><code>// El usuario pega: "abc123xyz#state-789def"
const hashIndex = rawCode.indexOf('#');
const code = rawCode.substring(0, hashIndex);   // "abc123xyz"
const state = rawCode.substring(hashIndex + 1);  // "state-789def"</code></pre>

      <div class="callout danger">
        <p><strong>ğŸ”¥ Detalle #2:</strong> Anthropic es el <strong>Ãºnico proveedor OAuth</strong> que requiere <code>Content-Type: application/json</code> en el token exchange. Google, GitHub, todos usan <code>application/x-www-form-urlencoded</code>.</p>
      </div>

      <pre><code>// Token exchange â€” JSON, NO form-urlencoded
const res = await fetch('https://console.anthropic.com/v1/oauth/token', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },  // â† Ãºnico en la industria
  body: JSON.stringify({
    grant_type: 'authorization_code',
    client_id: CLAUDE_CLIENT_ID,
    code,
    state,               // â† tambiÃ©n va en el body (no documentado)
    redirect_uri: REDIRECT_URI,
    code_verifier: codeVerifier,
  }),
});</code></pre>


      <!-- ==================== SECCIÃ“N 8 ==================== -->
      <h2><span class="section-number">8</span> Stealth Headers: HaciÃ©ndose Pasar por Claude Code CLI</h2>

      <p>Los tokens OAuth de Claude <strong>solo funcionan</strong> si el request parece venir del CLI oficial. Sin los headers correctos, Anthropic rechaza con <code>403 Forbidden</code>.</p>

      <p>Descubrimos esto investigando el cÃ³digo fuente de OpenClaw (cliente open source de Claude Code) y capturando las llamadas reales del CLI:</p>

      <pre><code>// ai-client.ts â€” Stealth headers para tokens OAuth
const isOAuth = credential.accessToken.startsWith('sk-ant-oat');

if (isOAuth) {
  headers['Authorization'] = `Bearer ${credential.accessToken}`;
  headers['anthropic-dangerous-direct-browser-access'] = 'true';
  headers['anthropic-beta'] = 'claude-code-20250219,oauth-2025-04-20,' +
    'fine-grained-tool-streaming-2025-05-14';
  headers['user-agent'] = 'claude-cli/2.1.2 (external, cli)';
  headers['x-app'] = 'cli';

  // El system prompt DEBE abrir con la identidad de Claude Code
  body.system = [
    { type: 'text', text: "You are Claude Code, Anthropic's official CLI." },
    { type: 'text', text: actualSystemPrompt },
  ];
} else {
  // API key normal â€” headers estÃ¡ndar
  headers['x-api-key'] = credential.accessToken;
  body.system = actualSystemPrompt;
}</code></pre>

      <p>Son <strong>5 headers especÃ­ficos</strong> + un system prompt de identidad. Sin cualquiera de ellos, el token es rechazado.</p>


      <!-- ==================== SECCIÃ“N 9 ==================== -->
      <h2><span class="section-number">9</span> Rate Limits: De Error CrÃ­ptico a Banner Elegante</h2>

      <p>Cuando el usuario agota su sesiÃ³n de Claude, la API devuelve un <code>429</code> con un header <code>retry-after</code>. Sin manejo adecuado, el usuario veÃ­a un error tÃ©cnico incomprensible.</p>

      <h3>La Cadena Completa de Manejo</h3>

      <div class="diagram">
        <pre><code>429 API Response (retry-after: 2520s)
         â”‚
         â–¼
TooManyRequestsError(minutes: 42)     â† Backend
         â”‚
         â–¼
JSON: { retryAfterMinutes: 42 }       â† HTTP Response
         â”‚
         â–¼
DioException (statusCode: 429)        â† Flutter HTTP
         â”‚
         â–¼
RateLimitFailure(minutes: 42)         â† Repository
         â”‚
         â–¼
AiCoachStatus.rateLimited             â† BLoC State
         â”‚
         â–¼
ğŸŸ¡ RateLimitBanner                    â† UI Widget
   "Intenta en ~42 min"</code></pre>
        <p class="diagram-caption">El error 429 transformÃ¡ndose de API response a UI amigable</p>
      </div>

      <h3>Backend: Retry con Backoff</h3>

      <pre><code>// ai-client.ts â€” 3 reintentos con backoff
if (res.status === 429) {
  const retryAfter = res.headers.get('retry-after');
  const rawWaitMs = retryAfter ? Number(retryAfter) * 1000 : (attempt + 1) * 5000;
  const minutes = Math.max(1, Math.ceil(rawWaitMs / 60000));

  // Si hay que esperar mÃ¡s de 1 minuto, no tiene sentido reintentar
  if (rawWaitMs > 60000) {
    throw new TooManyRequestsError(
      `Has alcanzado el lÃ­mite de uso de Claude. Intenta en ~${minutes} min.`,
      minutes,
    );
  }
  // Si es poco tiempo, esperar y reintentar
  await sleep(Math.min(rawWaitMs, 15000));
}</code></pre>

      <h3>Flutter: Error Tipado â†’ UI</h3>

      <pre><code>// ai_coach_repository_impl.dart
if (statusCode == 429) {
  final retryMinutes = errorData?['retryAfterMinutes'] as int?;
  return RateLimitFailure(
    message: message,
    retryAfterMinutes: retryMinutes,
  );
}

// ai_coach_bloc.dart
if (failure is RateLimitFailure) {
  emit(state.copyWith(
    status: AiCoachStatus.rateLimited,
    retryAfterMinutes: failure.retryAfterMinutes,
  ));
}</code></pre>

      <p>El resultado: en vez de un crash, el usuario ve un banner con gradiente amber, Ã­cono de timer y los minutos exactos de espera.</p>


      <!-- ==================== SECCIÃ“N 10 ==================== -->
      <h2><span class="section-number">10</span> OptimizaciÃ³n: 39 Segundos â†’ 8 Segundos</h2>

      <p>El plan semanal inicialmente tomaba <strong>39 segundos</strong> porque el agente ejecutaba 6 llamadas secuenciales a la API (una por iteraciÃ³n del tool loop). Cada iteraciÃ³n: Claude decide quÃ© tool â†’ ejecuta â†’ recibe resultado â†’ decide otra â†’ repite.</p>

      <div class="comparison">
        <div class="comparison-box bad">
          <h4>âŒ Agent Loop (39s)</h4>
          <pre><code>// 6 API calls secuenciales:
// Claude pide tool 1 â†’ ejecuta
// Claude pide tool 2 â†’ ejecuta
// Claude pide tool 3 â†’ ejecuta
// Claude escribe plan â†’ save tool
// 4 rondas ida y vuelta</code></pre>
        </div>
        <div class="comparison-box good">
          <h4>âœ… Pre-fetch (8s)</h4>
          <pre><code>// 3 queries en paralelo (~50ms)
// + 1 API call con todo
// = 4.7x mÃ¡s rÃ¡pido</code></pre>
        </div>
      </div>

      <p>La implementaciÃ³n real. Nota cÃ³mo reutilizamos las <strong>mismas funciones de las tools</strong> del agente, pero las llamamos directamente sin el loop â€” las tools son funciones puras que reciben <code>userId</code> y <code>args</code>:</p>

      <pre><code>// weekly-plan.service.ts â€” ImplementaciÃ³n real
import { getUserSkills } from '../tools/query-skills.tool';
import { getJourneyStats } from '../tools/get-stats.tool';
import { analyzePracticePatterns } from '../tools/analyze-patterns.tool';
import { saveWeeklyPlan } from '../tools/create-plan.tool';

const PLAN_TIMEOUT_MS = 60_000; // 1 minuto mÃ¡ximo

export async function generateWeeklyPlanDirect(userId: string) {
  return Promise.race([
    generatePlan(userId),
    planTimeout(), // misma tÃ©cnica que el agent runner
  ]);
}

async function generatePlan(userId: string) {
  // 1. Pre-fetch: 3 queries en paralelo (~50ms total)
  const [skills, stats, patterns] = await Promise.all([
    getUserSkills(userId, {}),
    getJourneyStats(userId, {}),
    analyzePracticePatterns(userId, {}),
  ]);

  // 2. Construir prompt con TODOS los datos embebidos como JSON
  const userPrompt = buildWeeklyPlanPrompt(skills.data, stats.data, patterns.data);

  // 3. UNA sola llamada a la API â€” sin tools, sin loop
  const result = await chatCompletion(
    [{ role: 'system', content: PLAN_SYSTEM_PROMPT },
     { role: 'user', content: userPrompt }],
    undefined, // â† sin tools
    userId,
  );

  // 4. Parsear y guardar
  const { planMarkdown, insights } = parsePlanResponse(result.content);
  await saveWeeklyPlan(userId, { content: planMarkdown, insights });

  return { response: result.content, toolsUsed: ['get_user_skills',
    'get_journey_stats', 'analyze_practice_patterns', 'save_weekly_plan'] };
}</code></pre>

      <pre><code>// weekly-plan.prompt.ts â€” Los datos van como JSON en el prompt
export function buildWeeklyPlanPrompt(
  skillsData: unknown, statsData: unknown, patternsData: unknown,
): string {
  return `Genera mi plan semanal basÃ¡ndote en mis datos reales:

## Mis Skills
\`\`\`json
${JSON.stringify(skillsData, null, 2)}
\`\`\`

## EstadÃ­sticas del Journey
\`\`\`json
${JSON.stringify(statsData, null, 2)}
\`\`\`

## Patrones de PrÃ¡ctica
\`\`\`json
${JSON.stringify(patternsData, null, 2)}
\`\`\`

Con estos datos, genera mi plan semanal personalizado.`;
}</code></pre>

      <p>Para el <strong>chat libre</strong> mantenemos el agent loop porque cada pregunta es impredecible. Para el <strong>plan semanal</strong> pre-cargamos todos los datos con <code>Promise.all</code> (~50ms) y hacemos una sola llamada con todo embebido en el prompt.</p>

      <p>Resultado: <strong>4.7x mÃ¡s rÃ¡pido</strong> â€” de 39 segundos a ~8 segundos.</p>


      <!-- ==================== SECCIÃ“N 11 ==================== -->
      <h2><span class="section-number">11</span> Arquitectura Completa</h2>

      <h3>Backend (Bun + Hono + Prisma)</h3>

      <pre><code>modules/
â”œâ”€â”€ ai/
â”‚   â”œâ”€â”€ ai.controller.ts        # POST /chat, POST /weekly-plan
â”‚   â”œâ”€â”€ ai.service.ts            # Orquesta el agent runner
â”‚   â”œâ”€â”€ agent/
â”‚   â”‚   â”œâ”€â”€ agent-runner.ts      # Loop de tool calling (max 5 iteraciones)
â”‚   â”‚   â”œâ”€â”€ system-prompt.ts     # Prompt del TenK Coach
â”‚   â”‚   â”œâ”€â”€ tool-definitions.ts  # 5 tools con JSON Schema
â”‚   â”‚   â””â”€â”€ tool-executor.ts     # Dispatcher de tools
â”‚   â””â”€â”€ tools/
â”‚       â”œâ”€â”€ query-skills.tool.ts
â”‚       â”œâ”€â”€ query-sessions.tool.ts
â”‚       â”œâ”€â”€ get-stats.tool.ts
â”‚       â”œâ”€â”€ analyze-patterns.tool.ts
â”‚       â””â”€â”€ create-plan.tool.ts
â”œâ”€â”€ claude-oauth/
â”‚   â”œâ”€â”€ claude-oauth.controller.ts  # POST /init, POST /exchange, GET /status
â”‚   â”œâ”€â”€ claude-oauth.service.ts     # PKCE, token exchange, refresh
â”‚   â””â”€â”€ claude-oauth.repository.ts  # Prisma ops
lib/
â””â”€â”€ ai-client.ts                 # Per-user tokens â†’ stealth headers â†’ retry</code></pre>

      <h3>Flutter (Clean Architecture)</h3>

      <pre><code>features/ai_coach/
â”œâ”€â”€ data/
â”‚   â”œâ”€â”€ datasources/
â”‚   â”‚   â”œâ”€â”€ ai_coach_remote_datasource.dart
â”‚   â”‚   â””â”€â”€ claude_oauth_datasource.dart
â”‚   â”œâ”€â”€ models/
â”‚   â””â”€â”€ repositories/
â”‚       â””â”€â”€ ai_coach_repository_impl.dart  # _handleDioError â†’ RateLimitFailure
â”œâ”€â”€ domain/
â”‚   â”œâ”€â”€ entities/
â”‚   â”œâ”€â”€ repositories/
â”‚   â””â”€â”€ usecases/
â””â”€â”€ presentation/
    â”œâ”€â”€ bloc/
    â”‚   â”œâ”€â”€ ai_coach_bloc.dart     # initial | sending | success | error | rateLimited
    â”‚   â”œâ”€â”€ ai_coach_event.dart
    â”‚   â””â”€â”€ ai_coach_state.dart    # retryAfterMinutes field
    â”œâ”€â”€ pages/
    â”‚   â””â”€â”€ ai_coach_screen.dart
    â””â”€â”€ widgets/
        â”œâ”€â”€ rate_limit_banner.dart
        â”œâ”€â”€ claude_connect_sheet.dart
        â”œâ”€â”€ chat_message_bubble.dart
        â””â”€â”€ coach_empty_state.dart</code></pre>


      <!-- ==================== SECCIÃ“N 12 ==================== -->
      <h2><span class="section-number">12</span> Modelos de Base de Datos</h2>

      <pre><code>// schema.prisma â€” Modelos reales para OAuth, Conversaciones y Planes

model AiConversation {
  id        String   @id @default(cuid())
  userId    String   @map("user_id")
  title     String   @default("Nueva conversaciÃ³n")
  messages  Json     @default("[]")     // IChatMessage[] serializado
  context   Json     @default("{}")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  @@map("ai_conversations")
  @@index([userId])
}

model AiWeeklyReport {
  id             String   @id @default(cuid())
  userId         String   @map("user_id")
  weekStart      DateTime @map("week_start") @db.Date
  content        String   @db.Text          // Markdown del plan
  insights       Json     @default("[]")    // IWeeklyInsight[] tipado
  skillsAnalyzed Json     @default("[]") @map("skills_analyzed")
  createdAt      DateTime @default(now()) @map("created_at")
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  @@unique([userId, weekStart])  // Un plan por semana por usuario
  @@map("ai_weekly_reports")
  @@index([userId])
}

model ClaudeCredential {
  id           String   @id @default(cuid())
  userId       String   @unique @map("user_id")
  accessToken  String   @map("access_token") @db.Text
  refreshToken String   @map("refresh_token") @db.Text
  expiresAt    DateTime @map("expires_at")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  @@map("claude_credentials")
}

model OAuthState {
  id            String   @id @default(cuid())
  userId        String   @map("user_id")
  state         String   @unique
  codeVerifier  String   @map("code_verifier")
  expiresAt     DateTime @map("expires_at")
  createdAt     DateTime @default(now()) @map("created_at")
  @@map("oauth_states")
  @@index([state])
  @@index([expiresAt])
}</code></pre>

      <p>Detalles clave del schema:</p>
      <ul>
        <li><code>AiConversation.messages</code> es un <code>Json</code> que almacena el array completo de <code>IChatMessage[]</code> â€” incluyendo los tool_calls â€” para poder reanudar conversaciones.</li>
        <li><code>AiWeeklyReport</code> tiene un <code>@@unique([userId, weekStart])</code> que permite hacer upsert: si generas un nuevo plan la misma semana, reemplaza el anterior.</li>
        <li><code>ClaudeCredential.userId</code> es <code>@unique</code> â€” un usuario, una credencial. Conectar de nuevo reemplaza la anterior.</li>
        <li><code>OAuthState.expiresAt</code> con index permite limpiar estados expirados eficientemente.</li>
      </ul>


      <!-- ==================== SECCIÃ“N 13 ==================== -->
      <h2><span class="section-number">13</span> Provider Fallback: La Cadena de 3 Niveles</h2>

      <p>El sistema de credenciales tiene <strong>3 niveles de fallback</strong> para maximizar la disponibilidad. Si un nivel falla o no tiene credenciales, intenta el siguiente automÃ¡ticamente:</p>

      <div class="diagram">
        <pre><code>chatCompletion(messages, tools, userId)
         â”‚
         â–¼
â”Œâ”€ Nivel 1: Per-User OAuth (DB) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  claudeOAuthService.getUserCredential(userId)       â”‚
â”‚  â†’ ClaudeCredential table â†’ accessToken             â”‚
â”‚  â†’ Auto-refresh si expirado                         â”‚
â”‚  â†’ Headers: stealth (OAuth tokens)                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚ null? (no conectado)
           â–¼
â”Œâ”€ Nivel 2: System Anthropic (Keychain/File) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  readClaudeCredentials()                             â”‚
â”‚  â†’ macOS Keychain: "Claude Code-credentials"        â”‚
â”‚  â†’ Fallback: ~/.claude/.credentials.json             â”‚
â”‚  â†’ Auto-refresh si expirado via OAuth refresh_token  â”‚
â”‚  â†’ Headers: stealth (same OAuth format)              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚ null? (no disponible)
           â–¼
â”Œâ”€ Nivel 3: OpenAI Codex (File) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  readCodexCredentials()                              â”‚
â”‚  â†’ ~/.codex/auth.json â†’ access_token                â”‚
â”‚  â†’ Model: gpt-4o (en vez de claude-sonnet-4)        â”‚
â”‚  â†’ Headers: estÃ¡ndar OpenAI                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>
        <p class="diagram-caption">3-tier provider fallback: per-user DB â†’ system Keychain â†’ OpenAI</p>
      </div>

      <pre><code>// ai-client.ts â€” ImplementaciÃ³n real del fallback chain
export async function chatCompletion(
  messages: IChatMessage[], tools?: IToolDefinition[], userId?: string,
): Promise&lt;IChatResponse&gt; {

  // Nivel 1: Credencial del usuario (Claude OAuth via DB)
  if (userId) {
    const userCred = await claudeOAuthService.getUserCredential(userId);
    if (userCred) {
      return callAnthropic(
        { provider: 'anthropic', accessToken: userCred.accessToken,
          refreshToken: userCred.refreshToken, expiresAt: userCred.expiresAt },
        messages, tools,
      );
    }
  }

  // Nivel 2: Credencial del sistema (Keychain/archivo)
  const systemCred = await readClaudeCredentials();
  if (systemCred) return callAnthropic(systemCred, messages, tools);

  // Nivel 3: OpenAI como Ãºltimo recurso
  const openaiCred = readCodexCredentials();
  if (openaiCred) return callOpenAI(openaiCred, messages, tools);

  throw new Error('No AI credentials available');
}</code></pre>

      <h3>Lectura del macOS Keychain</h3>

      <p>En servidores macOS, las credenciales de Claude Code se almacenan en el Keychain del sistema. El backend las lee ejecutando <code>security</code> â€” el mismo CLI que usa Claude Code internamente:</p>

      <pre><code>// ai-credentials.ts â€” Leer del Keychain de macOS
function readClaudeFromKeychain(): IOAuthCredential | null {
  if (platform() !== 'darwin') return null;

  // Claude Code guarda en diferentes "accounts"
  const accounts = [process.env.USER ?? 'root', 'Claude Code'];

  for (const account of accounts) {
    try {
      const raw = execSync(
        `security find-generic-password -s "Claude Code-credentials" -a "${account}" -w`,
        { encoding: 'utf8', timeout: 5000 },
      ).trim();

      const data = JSON.parse(raw);
      const oauth = data.claudeAiOauth;
      if (!oauth?.accessToken) continue;

      // Normalizar expiresAt (puede venir en segundos o milisegundos)
      const expiresAt = oauth.expiresAt &lt; 10_000_000_000
        ? oauth.expiresAt * 1000  // era segundos
        : oauth.expiresAt;        // ya era ms

      return { provider: 'anthropic', accessToken: oauth.accessToken,
        refreshToken: oauth.refreshToken ?? null, expiresAt };
    } catch { continue; }
  }
  return null;
}</code></pre>

      <h3>Auto-Refresh de Tokens</h3>

      <p>Si un token estÃ¡ expirado pero tiene <code>refresh_token</code>, el sistema lo refresca automÃ¡ticamente y persiste el nuevo token en la misma ubicaciÃ³n (Keychain o DB segÃºn el nivel):</p>

      <pre><code>// ai-token-refresh.ts
const CLAUDE_OAUTH_CLIENT_ID = '9d1c250a-e61b-44d9-88ed-5944d1962f5e';
const TOKEN_ENDPOINT = 'https://console.anthropic.com/v1/oauth/token';

export async function refreshClaudeToken(refreshToken: string): Promise&lt;IOAuthCredential | null&gt; {
  const res = await fetch(TOKEN_ENDPOINT, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      grant_type: 'refresh_token',
      client_id: CLAUDE_OAUTH_CLIENT_ID,
      refresh_token: refreshToken,
    }),
  });
  if (!res.ok) return null;

  const data = await res.json();
  const SAFETY_BUFFER = 5 * 60 * 1000; // 5 min antes de expiraciÃ³n

  return {
    provider: 'anthropic',
    accessToken: data.access_token,
    refreshToken: data.refresh_token,
    expiresAt: Date.now() + data.expires_in * 1000 - SAFETY_BUFFER,
  };
}</code></pre>

      <p>El <code>SAFETY_BUFFER</code> de 5 minutos asegura que el token se refresca antes de expirar realmente, evitando ventanas donde el token podrÃ­a estar "casi expirado" y fallar a mitad de una llamada.</p>


      <!-- ==================== SECCIÃ“N 14 ==================== -->
      <h2><span class="section-number">14</span> ImplementaciÃ³n Real de las Herramientas</h2>

      <p>Cada herramienta es una funciÃ³n pura que recibe <code>(userId, args)</code> y retorna <code>TAgentToolResult</code>. Veamos quÃ© hace cada una realmente bajo el capÃ³:</p>

      <h3>get_user_skills â€” Nivel de MaestrÃ­a Calculado</h3>

      <pre><code>// query-skills.tool.ts
export async function getUserSkills(userId: string, args: Record&lt;string, unknown&gt;) {
  const includeArchived = (args.includeArchived as boolean) ?? false;
  const skills = await skillRepository.findAllByUserId(userId, includeArchived);

  const data = skills.map((skill) =&gt; {
    const totalHours = skill.sessions.reduce((sum, s) =&gt; sum + Number(s.hours), 0);
    const mastery = getMasteryLevel(totalHours); // ğŸŒ±ğŸ“˜âš¡ğŸ”¥ğŸ‘‘

    return {
      id: skill.id,
      name: skill.name,
      emoji: skill.emoji || 'ğŸ“š',
      totalHours: Math.round(totalHours * 10) / 10,
      goalHours: skill.goalHours,
      masteryLevel: `${mastery.emoji} ${mastery.name}`,
      sessionsCount: skill.sessions.length,
    };
  });
  return { success: true, data };
}</code></pre>

      <p>El nivel de maestrÃ­a se calcula en tiempo real sumando todas las sesiones â€” no es un campo guardado. Esto asegura que siempre refleje el estado actual.</p>

      <h3>analyze_practice_patterns â€” El DiagnÃ³stico Profundo</h3>

      <p>Esta es la herramienta mÃ¡s compleja. Analiza hasta 500 sesiones y calcula 4 mÃ©tricas:</p>

      <pre><code>// analyze-patterns.tool.ts â€” 4 anÃ¡lisis sobre hasta 500 sesiones
export async function analyzePracticePatterns(userId: string, args: Record&lt;string, unknown&gt;) {
  const sessions = await prisma.session.findMany({
    where: { skill: { userId, isArchived: false } },
    orderBy: { practiceDate: 'desc' },
    take: 500, // Ãºltimas 500 sesiones
  });

  return {
    success: true,
    data: {
      dayDistribution: analyzeDayDistribution(sessions),
      //â†’ [{day: 'Lun', sessions: 12, totalHours: 8.5}, ...]

      weeklyTrend: analyzeWeeklyTrend(sessions),
      //â†’ {weeks: [...], trend: 'improving'|'declining'|'stable',
      //   recentAvg: 4.2, olderAvg: 3.1}

      gaps: analyzeGaps(sessions),
      //â†’ {longestGap: 5, averageGap: 1.8, gapsOver3Days: 3}

      consistency: analyzeConsistency(sessions),
      //â†’ {activeDaysLast30: 22, consistencyScore: 'buena'}
    },
  };
}

// La tendencia compara las Ãºltimas 4 semanas vs las 4 anteriores
function analyzeWeeklyTrend(sessions) {
  // ... agrupa por semana ...
  const recent = weeks.slice(0, 4).average();
  const older = weeks.slice(4).average();
  const trend = recent &gt; older * 1.1 ? 'improving'
              : recent &lt; older * 0.9 ? 'declining' : 'stable';
  return { weeks, trend, recentAvg: recent, olderAvg: older };
}

// Consistencia: dÃ­as activos en los Ãºltimos 30 dÃ­as
function analyzeConsistency(sessions) {
  const activeDays = uniqueDaysInLast30(sessions);
  const score = activeDays &gt;= 25 ? 'excelente'
              : activeDays &gt;= 18 ? 'buena'
              : activeDays &gt;= 10 ? 'regular' : 'baja';
  return { activeDaysLast30: activeDays, consistencyScore: score };
}</code></pre>

      <p>El modelo recibe estos datos estructurados y puede hacer observaciones como <em>"Tu tendencia es creciente â€” promediabas 3.1h/semana y ahora estÃ¡s en 4.2h. Â¡Sigue asÃ­!"</em> â€” toda basada en datos reales, no en intuiciÃ³n.</p>

      <h3>save_weekly_plan â€” Upsert Inteligente</h3>

      <pre><code>// create-plan.tool.ts â€” Calcula el lunes de la semana actual
export async function saveWeeklyPlan(userId: string, args: Record&lt;string, unknown&gt;) {
  const content = args.content as string;
  const insights = args.insights as IWeeklyInsight[];

  // Calcular inicio de semana (lunes)
  const now = new Date();
  const dayOfWeek = now.getDay();
  const mondayOffset = dayOfWeek === 0 ? -6 : 1 - dayOfWeek;
  const weekStart = new Date(now);
  weekStart.setDate(now.getDate() + mondayOffset);
  weekStart.setHours(0, 0, 0, 0);

  // Upsert: si ya hay plan esta semana, actualizarlo
  const existing = await aiRepository.findWeeklyReportByWeek(userId, weekStart);
  if (existing) {
    await prisma.aiWeeklyReport.update({ where: { id: existing.id }, data: { content, insights } });
  } else {
    await aiRepository.createWeeklyReport({ userId, weekStart, content, insights, skillsAnalyzed: [] });
  }

  return { success: true, data: { message: 'Plan guardado', weekStart } };
}</code></pre>


      <!-- ==================== SECCIÃ“N 15 ==================== -->
      <h2><span class="section-number">15</span> Parsers: Formato Unificado entre Providers</h2>

      <p>Anthropic y OpenAI retornan tool calls en formatos <strong>completamente diferentes</strong>. Nuestros parsers normalizan ambos a una interfaz comÃºn <code>IChatResponse</code>:</p>

      <pre><code>// Interfaz unificada que usa todo el sistema
interface IChatResponse {
  content: string | null;
  toolCalls: IToolCall[];
  provider: 'anthropic' | 'openai';
  usage?: { inputTokens: number; outputTokens: number };
}</code></pre>

      <div class="comparison">
        <div class="comparison-box bad">
          <h4>Anthropic Format</h4>
          <pre><code>// Tool calls vienen como "content blocks"
{
  content: [
    { type: "text", text: "..." },
    { type: "tool_use",
      id: "toolu_xxx",
      name: "get_user_skills",
      input: { includeArchived: false }
    }
  ]
}</code></pre>
        </div>
        <div class="comparison-box good">
          <h4>OpenAI Format</h4>
          <pre><code>// Tool calls son un campo separado
{
  choices: [{
    message: {
      content: "...",
      tool_calls: [{
        id: "call_xxx",
        type: "function",
        function: {
          name: "get_user_skills",
          arguments: "{\"includeArchived\":false}"
        }
      }]
    }
  }]
}</code></pre>
        </div>
      </div>

      <pre><code>// ai-parsers.ts â€” Normalizar a formato unificado
export function parseAnthropicResponse(data: AnthropicResponse): IChatResponse {
  const content = data.content
    ?.filter((b) =&gt; b.type === 'text')
    .map((b) =&gt; b.text)
    .join('') || null;

  const toolCalls = data.content
    .filter((b) =&gt; b.type === 'tool_use')
    .map((b) =&gt; ({
      id: b.id,
      type: 'function' as const,
      function: { name: b.name, arguments: JSON.stringify(b.input) },
    }));

  return { content, toolCalls, provider: 'anthropic',
    usage: data.usage ? { inputTokens: data.usage.input_tokens,
      outputTokens: data.usage.output_tokens } : undefined };
}

// Los tool_results tambiÃ©n se convierten en sentido inverso:
// Nuestro formato â†’ Anthropic "user message con tool_result content block"
export function convertToAnthropicMsg(msg) {
  if (msg.role === 'tool') {
    return {
      role: 'user',
      content: [{ type: 'tool_result', tool_use_id: msg.tool_call_id,
        content: msg.content }],
    };
  }
  // ... assistant messages con tool_calls â†’ content blocks
}</code></pre>

      <p>Sin los parsers, tendrÃ­amos que escribir cÃ³digo diferente para cada provider en cada parte del sistema. Con ellos, el agent-runner es <strong>completamente agnÃ³stico del provider</strong> â€” funciona igual con Claude o GPT-4o.</p>


      <!-- ==================== TAKEAWAYS ==================== -->
      <div class="takeaways">
        <h3>ğŸ’¡ Lecciones Aprendidas</h3>
        <ol>
          <li><strong>El agent loop es poderoso pero costoso</strong> â€” cada iteraciÃ³n es una API call. Usa pre-fetch cuando el flujo es predecible.</li>
          <li><strong>El system prompt es el 80% del comportamiento</strong> â€” un buen prompt convierte un LLM genÃ©rico en un experto especializado. Incluye parallel tool calling para reducir iteraciones.</li>
          <li><strong>Tool calling > RAG para datos estructurados</strong> â€” en vez de embeber todo en el contexto, deja que el modelo pida solo lo que necesita.</li>
          <li><strong>Siempre aislar por userId en el backend</strong>, nunca confiar en el input del modelo para autenticaciÃ³n.</li>
          <li><strong>Los guardrails importan</strong> â€” lÃ­mite de iteraciones, timeouts con <code>Promise.race</code>, y manejo de rate limits son esenciales en producciÃ³n.</li>
          <li><strong>Anthropic tiene sus particularidades</strong> â€” JSON en token exchange, <code>code#state</code>, stealth headers. Documenta todo porque no lo encontrarÃ¡s en su docs oficiales.</li>
          <li><strong>Cada usuario con su token = escalabilidad natural</strong> â€” zero API cost para el developer y rate limits individuales.</li>
          <li><strong>Normaliza los formatos entre providers</strong> â€” Anthropic y OpenAI retornan tool calls de forma diferente. Un parser intermedio hace que el agent runner sea agnÃ³stico del provider.</li>
          <li><strong>Las tools como funciones puras</strong> â€” el mismo <code>getUserSkills()</code> se usa en el agent loop Y en el pre-fetch del plan semanal. ReutilizaciÃ³n real.</li>
          <li><strong>El fallback chain con auto-refresh</strong> â€” 3 niveles de credenciales con refresh automÃ¡tico. El usuario nunca ve un error de autenticaciÃ³n si hay cualquier credencial disponible.</li>
        </ol>
      </div>


      <!-- ==================== SCREENSHOTS ==================== -->
      <h2>ğŸ“± La App en AcciÃ³n</h2>

      <div class="post-gallery">
        <figure>
          <img src="post/post9phone.png" alt="TenK App â€” Vista principal con grid de progreso">
          <figcaption>Vista principal de la app</figcaption>
        </figure>
        <figure>
          <img src="post/post9phone2.png" alt="TenK App â€” TÃ©cnica Pomodoro">
          <figcaption>TÃ©cnica Pomodoro integrada</figcaption>
        </figure>
      </div>

      <div class="post-image">
        <figure>
          <img src="post/web.png" alt="TenK â€” Landing page web" style="max-width: 700px;">
          <figcaption>Landing page en <a href="https://tenk.oventlabs.com">tenk.oventlabs.com</a></figcaption>
        </figure>
      </div>


      <!-- FOOTER -->
      <div class="post-footer">
        <p>Escrito por <strong>Oscar MartÃ­nez</strong> â€” 11 de febrero de 2026</p>
        <p style="margin-top: 10px; color: var(--text-muted);">
          <a href="https://tenk.oventlabs.com">Prueba TenK</a> &nbsp;|&nbsp;
          <a href="10k-hours-tracker.html">Ver el devlog completo</a> &nbsp;|&nbsp;
          <a href="index.html">Volver al inicio</a>
        </p>
      </div>

    </div>
  </main>

</body>
</html>
